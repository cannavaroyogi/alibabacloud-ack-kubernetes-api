"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class Addon extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'config',
            disabled: 'disabled',
            name: 'name',
        };
    }
    static types() {
        return {
            config: 'string',
            disabled: 'boolean',
            name: 'string',
        };
    }
}
exports.Addon = Addon;
class DataDisk extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoSnapshotPolicyId: 'auto_snapshot_policy_id',
            category: 'category',
            encrypted: 'encrypted',
            performanceLevel: 'performance_level',
            size: 'size',
        };
    }
    static types() {
        return {
            autoSnapshotPolicyId: 'string',
            category: 'string',
            encrypted: 'string',
            performanceLevel: 'string',
            size: 'number',
        };
    }
}
exports.DataDisk = DataDisk;
class MaintenanceWindow extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            maintenanceTime: 'maintenance_time',
            weeklyPeriod: 'weekly_period',
        };
    }
    static types() {
        return {
            duration: 'string',
            enable: 'boolean',
            maintenanceTime: 'string',
            weeklyPeriod: 'string',
        };
    }
}
exports.MaintenanceWindow = MaintenanceWindow;
class Runtime extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            version: 'version',
        };
    }
    static types() {
        return {
            name: 'string',
            version: 'string',
        };
    }
}
exports.Runtime = Runtime;
class Tag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.Tag = Tag;
class Taint extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            effect: 'effect',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            effect: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.Taint = Taint;
class StandardComponentsValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            version: 'version',
            description: 'description',
            required: 'required',
            disabled: 'disabled',
        };
    }
    static types() {
        return {
            name: 'string',
            version: 'string',
            description: 'string',
            required: 'string',
            disabled: 'boolean',
        };
    }
}
exports.StandardComponentsValue = StandardComponentsValue;
class AttachInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuPolicy: 'cpu_policy',
            formatDisk: 'format_disk',
            imageId: 'image_id',
            instances: 'instances',
            isEdgeWorker: 'is_edge_worker',
            keepInstanceName: 'keep_instance_name',
            keyPair: 'key_pair',
            nodepoolId: 'nodepool_id',
            password: 'password',
            rdsInstances: 'rds_instances',
            runtime: 'runtime',
            tags: 'tags',
            userData: 'user_data',
        };
    }
    static types() {
        return {
            cpuPolicy: 'string',
            formatDisk: 'boolean',
            imageId: 'string',
            instances: { 'type': 'array', 'itemType': 'string' },
            isEdgeWorker: 'boolean',
            keepInstanceName: 'boolean',
            keyPair: 'string',
            nodepoolId: 'string',
            password: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            runtime: Runtime,
            tags: { 'type': 'array', 'itemType': Tag },
            userData: 'string',
        };
    }
}
exports.AttachInstancesRequest = AttachInstancesRequest;
class AttachInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': AttachInstancesResponseBodyList },
            taskId: 'string',
        };
    }
}
exports.AttachInstancesResponseBody = AttachInstancesResponseBody;
class AttachInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttachInstancesResponseBody,
        };
    }
}
exports.AttachInstancesResponse = AttachInstancesResponse;
class CancelClusterUpgradeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.CancelClusterUpgradeResponse = CancelClusterUpgradeResponse;
class CancelComponentUpgradeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.CancelComponentUpgradeResponse = CancelComponentUpgradeResponse;
class CancelTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.CancelTaskResponse = CancelTaskResponse;
class CancelWorkflowRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
        };
    }
    static types() {
        return {
            action: 'string',
        };
    }
}
exports.CancelWorkflowRequest = CancelWorkflowRequest;
class CancelWorkflowResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.CancelWorkflowResponse = CancelWorkflowResponse;
class CreateAutoscalingConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coolDownDuration: 'cool_down_duration',
            expander: 'expander',
            gpuUtilizationThreshold: 'gpu_utilization_threshold',
            scaleDownEnabled: 'scale_down_enabled',
            scanInterval: 'scan_interval',
            unneededDuration: 'unneeded_duration',
            utilizationThreshold: 'utilization_threshold',
        };
    }
    static types() {
        return {
            coolDownDuration: 'string',
            expander: 'string',
            gpuUtilizationThreshold: 'string',
            scaleDownEnabled: 'boolean',
            scanInterval: 'string',
            unneededDuration: 'string',
            utilizationThreshold: 'string',
        };
    }
}
exports.CreateAutoscalingConfigRequest = CreateAutoscalingConfigRequest;
class CreateAutoscalingConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.CreateAutoscalingConfigResponse = CreateAutoscalingConfigResponse;
class CreateClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addons: 'addons',
            apiAudiences: 'api_audiences',
            chargeType: 'charge_type',
            cisEnabled: 'cis_enabled',
            cloudMonitorFlags: 'cloud_monitor_flags',
            clusterDomain: 'cluster_domain',
            clusterSpec: 'cluster_spec',
            clusterType: 'cluster_type',
            containerCidr: 'container_cidr',
            controlplaneLogComponents: 'controlplane_log_components',
            controlplaneLogProject: 'controlplane_log_project',
            controlplaneLogTtl: 'controlplane_log_ttl',
            cpuPolicy: 'cpu_policy',
            customSan: 'custom_san',
            deletionProtection: 'deletion_protection',
            disableRollback: 'disable_rollback',
            enableRrsa: 'enable_rrsa',
            encryptionProviderKey: 'encryption_provider_key',
            endpointPublicAccess: 'endpoint_public_access',
            formatDisk: 'format_disk',
            imageId: 'image_id',
            imageType: 'image_type',
            instances: 'instances',
            ipStack: 'ip_stack',
            isEnterpriseSecurityGroup: 'is_enterprise_security_group',
            keepInstanceName: 'keep_instance_name',
            keyPair: 'key_pair',
            kubernetesVersion: 'kubernetes_version',
            loadBalancerSpec: 'load_balancer_spec',
            loggingType: 'logging_type',
            loginPassword: 'login_password',
            masterAutoRenew: 'master_auto_renew',
            masterAutoRenewPeriod: 'master_auto_renew_period',
            masterCount: 'master_count',
            masterInstanceChargeType: 'master_instance_charge_type',
            masterInstanceTypes: 'master_instance_types',
            masterPeriod: 'master_period',
            masterPeriodUnit: 'master_period_unit',
            masterSystemDiskCategory: 'master_system_disk_category',
            masterSystemDiskPerformanceLevel: 'master_system_disk_performance_level',
            masterSystemDiskSize: 'master_system_disk_size',
            masterSystemDiskSnapshotPolicyId: 'master_system_disk_snapshot_policy_id',
            masterVswitchIds: 'master_vswitch_ids',
            name: 'name',
            natGateway: 'nat_gateway',
            nodeCidrMask: 'node_cidr_mask',
            nodeNameMode: 'node_name_mode',
            nodePortRange: 'node_port_range',
            numOfNodes: 'num_of_nodes',
            osType: 'os_type',
            period: 'period',
            periodUnit: 'period_unit',
            platform: 'platform',
            podVswitchIds: 'pod_vswitch_ids',
            profile: 'profile',
            proxyMode: 'proxy_mode',
            rdsInstances: 'rds_instances',
            regionId: 'region_id',
            resourceGroupId: 'resource_group_id',
            runtime: 'runtime',
            securityGroupId: 'security_group_id',
            serviceAccountIssuer: 'service_account_issuer',
            serviceCidr: 'service_cidr',
            serviceDiscoveryTypes: 'service_discovery_types',
            snatEntry: 'snat_entry',
            socEnabled: 'soc_enabled',
            sshFlags: 'ssh_flags',
            tags: 'tags',
            taints: 'taints',
            timeoutMins: 'timeout_mins',
            timezone: 'timezone',
            userCa: 'user_ca',
            userData: 'user_data',
            vpcid: 'vpcid',
            vswitchIds: 'vswitch_ids',
            workerAutoRenew: 'worker_auto_renew',
            workerAutoRenewPeriod: 'worker_auto_renew_period',
            workerDataDisks: 'worker_data_disks',
            workerInstanceChargeType: 'worker_instance_charge_type',
            workerInstanceTypes: 'worker_instance_types',
            workerPeriod: 'worker_period',
            workerPeriodUnit: 'worker_period_unit',
            workerSystemDiskCategory: 'worker_system_disk_category',
            workerSystemDiskPerformanceLevel: 'worker_system_disk_performance_level',
            workerSystemDiskSize: 'worker_system_disk_size',
            workerSystemDiskSnapshotPolicyId: 'worker_system_disk_snapshot_policy_id',
            workerVswitchIds: 'worker_vswitch_ids',
            zoneId: 'zone_id',
        };
    }
    static types() {
        return {
            addons: { 'type': 'array', 'itemType': Addon },
            apiAudiences: 'string',
            chargeType: 'string',
            cisEnabled: 'boolean',
            cloudMonitorFlags: 'boolean',
            clusterDomain: 'string',
            clusterSpec: 'string',
            clusterType: 'string',
            containerCidr: 'string',
            controlplaneLogComponents: { 'type': 'array', 'itemType': 'string' },
            controlplaneLogProject: 'string',
            controlplaneLogTtl: 'string',
            cpuPolicy: 'string',
            customSan: 'string',
            deletionProtection: 'boolean',
            disableRollback: 'boolean',
            enableRrsa: 'boolean',
            encryptionProviderKey: 'string',
            endpointPublicAccess: 'boolean',
            formatDisk: 'boolean',
            imageId: 'string',
            imageType: 'string',
            instances: { 'type': 'array', 'itemType': 'string' },
            ipStack: 'string',
            isEnterpriseSecurityGroup: 'boolean',
            keepInstanceName: 'boolean',
            keyPair: 'string',
            kubernetesVersion: 'string',
            loadBalancerSpec: 'string',
            loggingType: 'string',
            loginPassword: 'string',
            masterAutoRenew: 'boolean',
            masterAutoRenewPeriod: 'number',
            masterCount: 'number',
            masterInstanceChargeType: 'string',
            masterInstanceTypes: { 'type': 'array', 'itemType': 'string' },
            masterPeriod: 'number',
            masterPeriodUnit: 'string',
            masterSystemDiskCategory: 'string',
            masterSystemDiskPerformanceLevel: 'string',
            masterSystemDiskSize: 'number',
            masterSystemDiskSnapshotPolicyId: 'string',
            masterVswitchIds: { 'type': 'array', 'itemType': 'string' },
            name: 'string',
            natGateway: 'boolean',
            nodeCidrMask: 'string',
            nodeNameMode: 'string',
            nodePortRange: 'string',
            numOfNodes: 'number',
            osType: 'string',
            period: 'number',
            periodUnit: 'string',
            platform: 'string',
            podVswitchIds: { 'type': 'array', 'itemType': 'string' },
            profile: 'string',
            proxyMode: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            regionId: 'string',
            resourceGroupId: 'string',
            runtime: Runtime,
            securityGroupId: 'string',
            serviceAccountIssuer: 'string',
            serviceCidr: 'string',
            serviceDiscoveryTypes: { 'type': 'array', 'itemType': 'string' },
            snatEntry: 'boolean',
            socEnabled: 'boolean',
            sshFlags: 'boolean',
            tags: { 'type': 'array', 'itemType': Tag },
            taints: { 'type': 'array', 'itemType': Taint },
            timeoutMins: 'number',
            timezone: 'string',
            userCa: 'string',
            userData: 'string',
            vpcid: 'string',
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
            workerAutoRenew: 'boolean',
            workerAutoRenewPeriod: 'number',
            workerDataDisks: { 'type': 'array', 'itemType': CreateClusterRequestWorkerDataDisks },
            workerInstanceChargeType: 'string',
            workerInstanceTypes: { 'type': 'array', 'itemType': 'string' },
            workerPeriod: 'number',
            workerPeriodUnit: 'string',
            workerSystemDiskCategory: 'string',
            workerSystemDiskPerformanceLevel: 'string',
            workerSystemDiskSize: 'number',
            workerSystemDiskSnapshotPolicyId: 'string',
            workerVswitchIds: { 'type': 'array', 'itemType': 'string' },
            zoneId: 'string',
        };
    }
}
exports.CreateClusterRequest = CreateClusterRequest;
class CreateClusterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.CreateClusterResponseBody = CreateClusterResponseBody;
class CreateClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateClusterResponseBody,
        };
    }
}
exports.CreateClusterResponse = CreateClusterResponse;
class CreateClusterNodePoolRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoScaling: 'auto_scaling',
            count: 'count',
            interconnectConfig: 'interconnect_config',
            interconnectMode: 'interconnect_mode',
            kubernetesConfig: 'kubernetes_config',
            management: 'management',
            maxNodes: 'max_nodes',
            nodepoolInfo: 'nodepool_info',
            scalingGroup: 'scaling_group',
            teeConfig: 'tee_config',
        };
    }
    static types() {
        return {
            autoScaling: CreateClusterNodePoolRequestAutoScaling,
            count: 'number',
            interconnectConfig: CreateClusterNodePoolRequestInterconnectConfig,
            interconnectMode: 'string',
            kubernetesConfig: CreateClusterNodePoolRequestKubernetesConfig,
            management: CreateClusterNodePoolRequestManagement,
            maxNodes: 'number',
            nodepoolInfo: CreateClusterNodePoolRequestNodepoolInfo,
            scalingGroup: CreateClusterNodePoolRequestScalingGroup,
            teeConfig: CreateClusterNodePoolRequestTeeConfig,
        };
    }
}
exports.CreateClusterNodePoolRequest = CreateClusterNodePoolRequest;
class CreateClusterNodePoolResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodepoolId: 'nodepool_id',
        };
    }
    static types() {
        return {
            nodepoolId: 'string',
        };
    }
}
exports.CreateClusterNodePoolResponseBody = CreateClusterNodePoolResponseBody;
class CreateClusterNodePoolResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateClusterNodePoolResponseBody,
        };
    }
}
exports.CreateClusterNodePoolResponse = CreateClusterNodePoolResponse;
class CreateEdgeMachineRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostname: 'hostname',
            model: 'model',
            sn: 'sn',
        };
    }
    static types() {
        return {
            hostname: 'string',
            model: 'string',
            sn: 'string',
        };
    }
}
exports.CreateEdgeMachineRequest = CreateEdgeMachineRequest;
class CreateEdgeMachineResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            edgeMachineId: 'edge_machine_id',
            requestId: 'request_id',
        };
    }
    static types() {
        return {
            edgeMachineId: 'string',
            requestId: 'string',
        };
    }
}
exports.CreateEdgeMachineResponseBody = CreateEdgeMachineResponseBody;
class CreateEdgeMachineResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateEdgeMachineResponseBody,
        };
    }
}
exports.CreateEdgeMachineResponse = CreateEdgeMachineResponse;
class CreateKubernetesTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            clusterId: 'cluster_id',
            projectId: 'project_id',
            type: 'type',
        };
    }
    static types() {
        return {
            action: 'string',
            clusterId: 'string',
            projectId: 'string',
            type: 'string',
        };
    }
}
exports.CreateKubernetesTriggerRequest = CreateKubernetesTriggerRequest;
class CreateKubernetesTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            clusterId: 'cluster_id',
            id: 'id',
            projectId: 'project_id',
            type: 'type',
        };
    }
    static types() {
        return {
            action: 'string',
            clusterId: 'string',
            id: 'string',
            projectId: 'string',
            type: 'string',
        };
    }
}
exports.CreateKubernetesTriggerResponseBody = CreateKubernetesTriggerResponseBody;
class CreateKubernetesTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateKubernetesTriggerResponseBody,
        };
    }
}
exports.CreateKubernetesTriggerResponse = CreateKubernetesTriggerResponse;
class CreateTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            name: 'name',
            tags: 'tags',
            template: 'template',
            templateType: 'template_type',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            tags: 'string',
            template: 'string',
            templateType: 'string',
        };
    }
}
exports.CreateTemplateRequest = CreateTemplateRequest;
class CreateTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            templateId: 'template_id',
        };
    }
    static types() {
        return {
            templateId: 'string',
        };
    }
}
exports.CreateTemplateResponseBody = CreateTemplateResponseBody;
class CreateTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTemplateResponseBody,
        };
    }
}
exports.CreateTemplateResponse = CreateTemplateResponse;
class CreateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            clusterId: 'cluster_id',
            projectId: 'project_id',
            type: 'type',
        };
    }
    static types() {
        return {
            action: 'string',
            clusterId: 'string',
            projectId: 'string',
            type: 'string',
        };
    }
}
exports.CreateTriggerRequest = CreateTriggerRequest;
class CreateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            clusterId: 'cluster_id',
            id: 'id',
            projectId: 'project_id',
            type: 'type',
        };
    }
    static types() {
        return {
            action: 'string',
            clusterId: 'string',
            id: 'string',
            projectId: 'string',
            type: 'string',
        };
    }
}
exports.CreateTriggerResponseBody = CreateTriggerResponseBody;
class CreateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTriggerResponseBody,
        };
    }
}
exports.CreateTriggerResponse = CreateTriggerResponse;
class DeleteAlertContactResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteAlertContactResponse = DeleteAlertContactResponse;
class DeleteAlertContactGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteAlertContactGroupResponse = DeleteAlertContactGroupResponse;
class DeleteClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            keepSlb: 'keep_slb',
            retainAllResources: 'retain_all_resources',
            retainResources: 'retain_resources',
        };
    }
    static types() {
        return {
            keepSlb: 'boolean',
            retainAllResources: 'boolean',
            retainResources: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeleteClusterRequest = DeleteClusterRequest;
class DeleteClusterShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            keepSlb: 'keep_slb',
            retainAllResources: 'retain_all_resources',
            retainResourcesShrink: 'retain_resources',
        };
    }
    static types() {
        return {
            keepSlb: 'boolean',
            retainAllResources: 'boolean',
            retainResourcesShrink: 'string',
        };
    }
}
exports.DeleteClusterShrinkRequest = DeleteClusterShrinkRequest;
class DeleteClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteClusterResponse = DeleteClusterResponse;
class DeleteClusterNodepoolRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            force: 'force',
        };
    }
    static types() {
        return {
            force: 'boolean',
        };
    }
}
exports.DeleteClusterNodepoolRequest = DeleteClusterNodepoolRequest;
class DeleteClusterNodepoolResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'request_id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteClusterNodepoolResponseBody = DeleteClusterNodepoolResponseBody;
class DeleteClusterNodepoolResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteClusterNodepoolResponseBody,
        };
    }
}
exports.DeleteClusterNodepoolResponse = DeleteClusterNodepoolResponse;
class DeleteClusterNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            drainNode: 'drain_node',
            nodes: 'nodes',
            releaseNode: 'release_node',
        };
    }
    static types() {
        return {
            drainNode: 'boolean',
            nodes: { 'type': 'array', 'itemType': 'string' },
            releaseNode: 'boolean',
        };
    }
}
exports.DeleteClusterNodesRequest = DeleteClusterNodesRequest;
class DeleteClusterNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.DeleteClusterNodesResponseBody = DeleteClusterNodesResponseBody;
class DeleteClusterNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteClusterNodesResponseBody,
        };
    }
}
exports.DeleteClusterNodesResponse = DeleteClusterNodesResponse;
class DeleteEdgeMachineRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            force: 'force',
        };
    }
    static types() {
        return {
            force: 'string',
        };
    }
}
exports.DeleteEdgeMachineRequest = DeleteEdgeMachineRequest;
class DeleteEdgeMachineResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteEdgeMachineResponse = DeleteEdgeMachineResponse;
class DeleteKubernetesTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteKubernetesTriggerResponse = DeleteKubernetesTriggerResponse;
class DeletePolicyInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceName: 'instance_name',
        };
    }
    static types() {
        return {
            instanceName: 'string',
        };
    }
}
exports.DeletePolicyInstanceRequest = DeletePolicyInstanceRequest;
class DeletePolicyInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instances: 'instances',
        };
    }
    static types() {
        return {
            instances: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeletePolicyInstanceResponseBody = DeletePolicyInstanceResponseBody;
class DeletePolicyInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeletePolicyInstanceResponseBody,
        };
    }
}
exports.DeletePolicyInstanceResponse = DeletePolicyInstanceResponse;
class DeleteTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteTemplateResponse = DeleteTemplateResponse;
class DeleteTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.DeleteTriggerResponse = DeleteTriggerResponse;
class DeployPolicyInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            namespaces: 'namespaces',
            parameters: 'parameters',
        };
    }
    static types() {
        return {
            action: 'string',
            namespaces: { 'type': 'array', 'itemType': 'string' },
            parameters: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.DeployPolicyInstanceRequest = DeployPolicyInstanceRequest;
class DeployPolicyInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instances: 'instances',
        };
    }
    static types() {
        return {
            instances: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeployPolicyInstanceResponseBody = DeployPolicyInstanceResponseBody;
class DeployPolicyInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeployPolicyInstanceResponseBody,
        };
    }
}
exports.DeployPolicyInstanceResponse = DeployPolicyInstanceResponse;
class DescirbeWorkflowResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'create_time',
            duration: 'duration',
            finishTime: 'finish_time',
            inputDataSize: 'input_data_size',
            jobName: 'job_name',
            jobNamespace: 'job_namespace',
            outputDataSize: 'output_data_size',
            status: 'status',
            totalBases: 'total_bases',
            totalReads: 'total_reads',
            userInputData: 'user_input_data',
        };
    }
    static types() {
        return {
            createTime: 'string',
            duration: 'string',
            finishTime: 'string',
            inputDataSize: 'string',
            jobName: 'string',
            jobNamespace: 'string',
            outputDataSize: 'string',
            status: 'string',
            totalBases: 'string',
            totalReads: 'string',
            userInputData: 'string',
        };
    }
}
exports.DescirbeWorkflowResponseBody = DescirbeWorkflowResponseBody;
class DescirbeWorkflowResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescirbeWorkflowResponseBody,
        };
    }
}
exports.DescirbeWorkflowResponse = DescirbeWorkflowResponse;
class DescribeAddonsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterType: 'cluster_type',
            region: 'region',
        };
    }
    static types() {
        return {
            clusterType: 'string',
            region: 'string',
        };
    }
}
exports.DescribeAddonsRequest = DescribeAddonsRequest;
class DescribeAddonsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentGroups: 'ComponentGroups',
            standardComponents: 'StandardComponents',
        };
    }
    static types() {
        return {
            componentGroups: { 'type': 'array', 'itemType': DescribeAddonsResponseBodyComponentGroups },
            standardComponents: { 'type': 'map', 'keyType': 'string', 'valueType': StandardComponentsValue },
        };
    }
}
exports.DescribeAddonsResponseBody = DescribeAddonsResponseBody;
class DescribeAddonsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeAddonsResponseBody,
        };
    }
}
exports.DescribeAddonsResponse = DescribeAddonsResponse;
class DescribeClusterAddonMetadataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configSchema: 'config_schema',
            name: 'name',
            version: 'version',
        };
    }
    static types() {
        return {
            configSchema: 'string',
            name: 'string',
            version: 'string',
        };
    }
}
exports.DescribeClusterAddonMetadataResponseBody = DescribeClusterAddonMetadataResponseBody;
class DescribeClusterAddonMetadataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterAddonMetadataResponseBody,
        };
    }
}
exports.DescribeClusterAddonMetadataResponse = DescribeClusterAddonMetadataResponse;
class DescribeClusterAddonUpgradeStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.DescribeClusterAddonUpgradeStatusResponse = DescribeClusterAddonUpgradeStatusResponse;
class DescribeClusterAddonsUpgradeStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentIds: 'componentIds',
        };
    }
    static types() {
        return {
            componentIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeClusterAddonsUpgradeStatusRequest = DescribeClusterAddonsUpgradeStatusRequest;
class DescribeClusterAddonsUpgradeStatusShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentIdsShrink: 'componentIds',
        };
    }
    static types() {
        return {
            componentIdsShrink: 'string',
        };
    }
}
exports.DescribeClusterAddonsUpgradeStatusShrinkRequest = DescribeClusterAddonsUpgradeStatusShrinkRequest;
class DescribeClusterAddonsUpgradeStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.DescribeClusterAddonsUpgradeStatusResponse = DescribeClusterAddonsUpgradeStatusResponse;
class DescribeClusterAddonsVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.DescribeClusterAddonsVersionResponse = DescribeClusterAddonsVersionResponse;
class DescribeClusterAttachScriptsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            arch: 'arch',
            formatDisk: 'format_disk',
            keepInstanceName: 'keep_instance_name',
            nodepoolId: 'nodepool_id',
            options: 'options',
            rdsInstances: 'rds_instances',
        };
    }
    static types() {
        return {
            arch: 'string',
            formatDisk: 'boolean',
            keepInstanceName: 'boolean',
            nodepoolId: 'string',
            options: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeClusterAttachScriptsRequest = DescribeClusterAttachScriptsRequest;
class DescribeClusterAttachScriptsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: 'string',
        };
    }
}
exports.DescribeClusterAttachScriptsResponse = DescribeClusterAttachScriptsResponse;
class DescribeClusterDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            clusterSpec: 'cluster_spec',
            clusterType: 'cluster_type',
            created: 'created',
            currentVersion: 'current_version',
            deletionProtection: 'deletion_protection',
            dockerVersion: 'docker_version',
            externalLoadbalancerId: 'external_loadbalancer_id',
            initVersion: 'init_version',
            maintenanceWindow: 'maintenance_window',
            masterUrl: 'master_url',
            metaData: 'meta_data',
            name: 'name',
            networkMode: 'network_mode',
            nextVersion: 'next_version',
            privateZone: 'private_zone',
            profile: 'profile',
            regionId: 'region_id',
            resourceGroupId: 'resource_group_id',
            securityGroupId: 'security_group_id',
            size: 'size',
            state: 'state',
            subnetCidr: 'subnet_cidr',
            tags: 'tags',
            updated: 'updated',
            vpcId: 'vpc_id',
            vswitchId: 'vswitch_id',
            workerRamRoleName: 'worker_ram_role_name',
            zoneId: 'zone_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            clusterSpec: 'string',
            clusterType: 'string',
            created: 'string',
            currentVersion: 'string',
            deletionProtection: 'boolean',
            dockerVersion: 'string',
            externalLoadbalancerId: 'string',
            initVersion: 'string',
            maintenanceWindow: MaintenanceWindow,
            masterUrl: 'string',
            metaData: 'string',
            name: 'string',
            networkMode: 'string',
            nextVersion: 'string',
            privateZone: 'boolean',
            profile: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            securityGroupId: 'string',
            size: 'number',
            state: 'string',
            subnetCidr: 'string',
            tags: { 'type': 'array', 'itemType': Tag },
            updated: 'string',
            vpcId: 'string',
            vswitchId: 'string',
            workerRamRoleName: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeClusterDetailResponseBody = DescribeClusterDetailResponseBody;
class DescribeClusterDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterDetailResponseBody,
        };
    }
}
exports.DescribeClusterDetailResponse = DescribeClusterDetailResponse;
class DescribeClusterEventsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            taskId: 'number',
        };
    }
}
exports.DescribeClusterEventsRequest = DescribeClusterEventsRequest;
class DescribeClusterEventsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            events: 'events',
            pageInfo: 'page_info',
        };
    }
    static types() {
        return {
            events: { 'type': 'array', 'itemType': DescribeClusterEventsResponseBodyEvents },
            pageInfo: DescribeClusterEventsResponseBodyPageInfo,
        };
    }
}
exports.DescribeClusterEventsResponseBody = DescribeClusterEventsResponseBody;
class DescribeClusterEventsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterEventsResponseBody,
        };
    }
}
exports.DescribeClusterEventsResponse = DescribeClusterEventsResponse;
class DescribeClusterLogsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeClusterLogsResponseBody },
        };
    }
}
exports.DescribeClusterLogsResponse = DescribeClusterLogsResponse;
class DescribeClusterNodePoolDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoScaling: 'auto_scaling',
            interconnectConfig: 'interconnect_config',
            interconnectMode: 'interconnect_mode',
            kubernetesConfig: 'kubernetes_config',
            management: 'management',
            maxNodes: 'max_nodes',
            nodepoolInfo: 'nodepool_info',
            scalingGroup: 'scaling_group',
            status: 'status',
            teeConfig: 'tee_config',
        };
    }
    static types() {
        return {
            autoScaling: DescribeClusterNodePoolDetailResponseBodyAutoScaling,
            interconnectConfig: DescribeClusterNodePoolDetailResponseBodyInterconnectConfig,
            interconnectMode: 'string',
            kubernetesConfig: DescribeClusterNodePoolDetailResponseBodyKubernetesConfig,
            management: DescribeClusterNodePoolDetailResponseBodyManagement,
            maxNodes: 'number',
            nodepoolInfo: DescribeClusterNodePoolDetailResponseBodyNodepoolInfo,
            scalingGroup: DescribeClusterNodePoolDetailResponseBodyScalingGroup,
            status: DescribeClusterNodePoolDetailResponseBodyStatus,
            teeConfig: DescribeClusterNodePoolDetailResponseBodyTeeConfig,
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBody = DescribeClusterNodePoolDetailResponseBody;
class DescribeClusterNodePoolDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterNodePoolDetailResponseBody,
        };
    }
}
exports.DescribeClusterNodePoolDetailResponse = DescribeClusterNodePoolDetailResponse;
class DescribeClusterNodePoolsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodepools: 'nodepools',
        };
    }
    static types() {
        return {
            nodepools: { 'type': 'array', 'itemType': DescribeClusterNodePoolsResponseBodyNodepools },
        };
    }
}
exports.DescribeClusterNodePoolsResponseBody = DescribeClusterNodePoolsResponseBody;
class DescribeClusterNodePoolsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterNodePoolsResponseBody,
        };
    }
}
exports.DescribeClusterNodePoolsResponse = DescribeClusterNodePoolsResponse;
class DescribeClusterNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceIds: 'instanceIds',
            nodepoolId: 'nodepool_id',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            state: 'state',
        };
    }
    static types() {
        return {
            instanceIds: 'string',
            nodepoolId: 'string',
            pageNumber: 'string',
            pageSize: 'string',
            state: 'string',
        };
    }
}
exports.DescribeClusterNodesRequest = DescribeClusterNodesRequest;
class DescribeClusterNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodes: 'nodes',
            page: 'page',
        };
    }
    static types() {
        return {
            nodes: { 'type': 'array', 'itemType': DescribeClusterNodesResponseBodyNodes },
            page: DescribeClusterNodesResponseBodyPage,
        };
    }
}
exports.DescribeClusterNodesResponseBody = DescribeClusterNodesResponseBody;
class DescribeClusterNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterNodesResponseBody,
        };
    }
}
exports.DescribeClusterNodesResponse = DescribeClusterNodesResponse;
class DescribeClusterResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeClusterResourcesResponseBody },
        };
    }
}
exports.DescribeClusterResourcesResponse = DescribeClusterResourcesResponse;
class DescribeClusterTasksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageInfo: 'page_info',
            requestId: 'requestId',
            tasks: 'tasks',
        };
    }
    static types() {
        return {
            pageInfo: DescribeClusterTasksResponseBodyPageInfo,
            requestId: 'string',
            tasks: { 'type': 'array', 'itemType': DescribeClusterTasksResponseBodyTasks },
        };
    }
}
exports.DescribeClusterTasksResponseBody = DescribeClusterTasksResponseBody;
class DescribeClusterTasksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterTasksResponseBody,
        };
    }
}
exports.DescribeClusterTasksResponse = DescribeClusterTasksResponse;
class DescribeClusterUserKubeconfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            privateIpAddress: 'PrivateIpAddress',
            temporaryDurationMinutes: 'TemporaryDurationMinutes',
        };
    }
    static types() {
        return {
            privateIpAddress: 'boolean',
            temporaryDurationMinutes: 'number',
        };
    }
}
exports.DescribeClusterUserKubeconfigRequest = DescribeClusterUserKubeconfigRequest;
class DescribeClusterUserKubeconfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'config',
            expiration: 'expiration',
        };
    }
    static types() {
        return {
            config: 'string',
            expiration: 'string',
        };
    }
}
exports.DescribeClusterUserKubeconfigResponseBody = DescribeClusterUserKubeconfigResponseBody;
class DescribeClusterUserKubeconfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterUserKubeconfigResponseBody,
        };
    }
}
exports.DescribeClusterUserKubeconfigResponse = DescribeClusterUserKubeconfigResponse;
class DescribeClusterV2UserKubeconfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            privateIpAddress: 'PrivateIpAddress',
        };
    }
    static types() {
        return {
            privateIpAddress: 'boolean',
        };
    }
}
exports.DescribeClusterV2UserKubeconfigRequest = DescribeClusterV2UserKubeconfigRequest;
class DescribeClusterV2UserKubeconfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'config',
        };
    }
    static types() {
        return {
            config: 'string',
        };
    }
}
exports.DescribeClusterV2UserKubeconfigResponseBody = DescribeClusterV2UserKubeconfigResponseBody;
class DescribeClusterV2UserKubeconfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClusterV2UserKubeconfigResponseBody,
        };
    }
}
exports.DescribeClusterV2UserKubeconfigResponse = DescribeClusterV2UserKubeconfigResponse;
class DescribeClustersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterType: 'clusterType',
            name: 'name',
        };
    }
    static types() {
        return {
            clusterType: 'string',
            name: 'string',
        };
    }
}
exports.DescribeClustersRequest = DescribeClustersRequest;
class DescribeClustersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeClustersResponseBody },
        };
    }
}
exports.DescribeClustersResponse = DescribeClustersResponse;
class DescribeClustersV1Request extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterSpec: 'cluster_spec',
            clusterType: 'cluster_type',
            name: 'name',
            pageNumber: 'page_number',
            pageSize: 'page_size',
            profile: 'profile',
            regionId: 'region_id',
        };
    }
    static types() {
        return {
            clusterSpec: 'string',
            clusterType: 'string',
            name: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            profile: 'string',
            regionId: 'string',
        };
    }
}
exports.DescribeClustersV1Request = DescribeClustersV1Request;
class DescribeClustersV1ResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusters: 'clusters',
            pageInfo: 'page_info',
        };
    }
    static types() {
        return {
            clusters: { 'type': 'array', 'itemType': DescribeClustersV1ResponseBodyClusters },
            pageInfo: DescribeClustersV1ResponseBodyPageInfo,
        };
    }
}
exports.DescribeClustersV1ResponseBody = DescribeClustersV1ResponseBody;
class DescribeClustersV1Response extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeClustersV1ResponseBody,
        };
    }
}
exports.DescribeClustersV1Response = DescribeClustersV1Response;
class DescribeEdgeMachineActiveProcessResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logs: 'logs',
            progress: 'progress',
            requestId: 'request_id',
            state: 'state',
            step: 'step',
        };
    }
    static types() {
        return {
            logs: 'string',
            progress: 'number',
            requestId: 'string',
            state: 'string',
            step: 'string',
        };
    }
}
exports.DescribeEdgeMachineActiveProcessResponseBody = DescribeEdgeMachineActiveProcessResponseBody;
class DescribeEdgeMachineActiveProcessResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeEdgeMachineActiveProcessResponseBody,
        };
    }
}
exports.DescribeEdgeMachineActiveProcessResponse = DescribeEdgeMachineActiveProcessResponse;
class DescribeEdgeMachineModelsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            models: 'models',
        };
    }
    static types() {
        return {
            models: { 'type': 'array', 'itemType': DescribeEdgeMachineModelsResponseBodyModels },
        };
    }
}
exports.DescribeEdgeMachineModelsResponseBody = DescribeEdgeMachineModelsResponseBody;
class DescribeEdgeMachineModelsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeEdgeMachineModelsResponseBody,
        };
    }
}
exports.DescribeEdgeMachineModelsResponse = DescribeEdgeMachineModelsResponse;
class DescribeEdgeMachineTunnelConfigDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceName: 'device_name',
            model: 'model',
            productKey: 'product_key',
            requestId: 'request_id',
            sn: 'sn',
            token: 'token',
            tunnelEndpoint: 'tunnel_endpoint',
        };
    }
    static types() {
        return {
            deviceName: 'string',
            model: 'string',
            productKey: 'string',
            requestId: 'string',
            sn: 'string',
            token: 'string',
            tunnelEndpoint: 'string',
        };
    }
}
exports.DescribeEdgeMachineTunnelConfigDetailResponseBody = DescribeEdgeMachineTunnelConfigDetailResponseBody;
class DescribeEdgeMachineTunnelConfigDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeEdgeMachineTunnelConfigDetailResponseBody,
        };
    }
}
exports.DescribeEdgeMachineTunnelConfigDetailResponse = DescribeEdgeMachineTunnelConfigDetailResponse;
class DescribeEdgeMachinesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hostname: 'hostname',
            lifeState: 'life_state',
            model: 'model',
            onlineState: 'online_state',
            pageNumber: 'page_number',
            pageSize: 'page_size',
        };
    }
    static types() {
        return {
            hostname: 'string',
            lifeState: 'string',
            model: 'string',
            onlineState: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
}
exports.DescribeEdgeMachinesRequest = DescribeEdgeMachinesRequest;
class DescribeEdgeMachinesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            edgeMachines: 'edge_machines',
            pageInfo: 'page_info',
        };
    }
    static types() {
        return {
            edgeMachines: { 'type': 'array', 'itemType': DescribeEdgeMachinesResponseBodyEdgeMachines },
            pageInfo: DescribeEdgeMachinesResponseBodyPageInfo,
        };
    }
}
exports.DescribeEdgeMachinesResponseBody = DescribeEdgeMachinesResponseBody;
class DescribeEdgeMachinesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeEdgeMachinesResponseBody,
        };
    }
}
exports.DescribeEdgeMachinesResponse = DescribeEdgeMachinesResponse;
class DescribeEventsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            pageNumber: 'page_number',
            pageSize: 'page_size',
            type: 'type',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            type: 'string',
        };
    }
}
exports.DescribeEventsRequest = DescribeEventsRequest;
class DescribeEventsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            events: 'events',
            pageInfo: 'page_info',
        };
    }
    static types() {
        return {
            events: { 'type': 'array', 'itemType': DescribeEventsResponseBodyEvents },
            pageInfo: DescribeEventsResponseBodyPageInfo,
        };
    }
}
exports.DescribeEventsResponseBody = DescribeEventsResponseBody;
class DescribeEventsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeEventsResponseBody,
        };
    }
}
exports.DescribeEventsResponse = DescribeEventsResponse;
class DescribeExternalAgentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            privateIpAddress: 'PrivateIpAddress',
        };
    }
    static types() {
        return {
            privateIpAddress: 'string',
        };
    }
}
exports.DescribeExternalAgentRequest = DescribeExternalAgentRequest;
class DescribeExternalAgentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'config',
        };
    }
    static types() {
        return {
            config: 'string',
        };
    }
}
exports.DescribeExternalAgentResponseBody = DescribeExternalAgentResponseBody;
class DescribeExternalAgentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeExternalAgentResponseBody,
        };
    }
}
exports.DescribeExternalAgentResponse = DescribeExternalAgentResponse;
class DescribeKubernetesVersionMetadataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterType: 'ClusterType',
            kubernetesVersion: 'KubernetesVersion',
            profile: 'Profile',
            region: 'Region',
            runtime: 'runtime',
        };
    }
    static types() {
        return {
            clusterType: 'string',
            kubernetesVersion: 'string',
            profile: 'string',
            region: 'string',
            runtime: 'string',
        };
    }
}
exports.DescribeKubernetesVersionMetadataRequest = DescribeKubernetesVersionMetadataRequest;
class DescribeKubernetesVersionMetadataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeKubernetesVersionMetadataResponseBody },
        };
    }
}
exports.DescribeKubernetesVersionMetadataResponse = DescribeKubernetesVersionMetadataResponse;
class DescribeNodePoolVulsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            vulRecords: 'vul_records',
            vulsFixServicePurchased: 'vuls_fix_service_purchased',
        };
    }
    static types() {
        return {
            vulRecords: { 'type': 'array', 'itemType': DescribeNodePoolVulsResponseBodyVulRecords },
            vulsFixServicePurchased: 'boolean',
        };
    }
}
exports.DescribeNodePoolVulsResponseBody = DescribeNodePoolVulsResponseBody;
class DescribeNodePoolVulsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeNodePoolVulsResponseBody,
        };
    }
}
exports.DescribeNodePoolVulsResponse = DescribeNodePoolVulsResponse;
class DescribePoliciesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.DescribePoliciesResponse = DescribePoliciesResponse;
class DescribePolicyDetailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            category: 'category',
            description: 'description',
            isDeleted: 'is_deleted',
            name: 'name',
            noConfig: 'no_config',
            severity: 'severity',
            template: 'template',
        };
    }
    static types() {
        return {
            action: 'string',
            category: 'string',
            description: 'string',
            isDeleted: 'number',
            name: 'string',
            noConfig: 'number',
            severity: 'string',
            template: 'string',
        };
    }
}
exports.DescribePolicyDetailsResponseBody = DescribePolicyDetailsResponseBody;
class DescribePolicyDetailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePolicyDetailsResponseBody,
        };
    }
}
exports.DescribePolicyDetailsResponse = DescribePolicyDetailsResponse;
class DescribePolicyGovernanceInClusterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            admitLog: 'admit_log',
            onState: 'on_state',
            totalViolations: 'totalViolations',
            violations: 'violations',
        };
    }
    static types() {
        return {
            admitLog: DescribePolicyGovernanceInClusterResponseBodyAdmitLog,
            onState: { 'type': 'array', 'itemType': DescribePolicyGovernanceInClusterResponseBodyOnState },
            totalViolations: DescribePolicyGovernanceInClusterResponseBodyTotalViolations,
            violations: DescribePolicyGovernanceInClusterResponseBodyViolations,
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBody = DescribePolicyGovernanceInClusterResponseBody;
class DescribePolicyGovernanceInClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePolicyGovernanceInClusterResponseBody,
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponse = DescribePolicyGovernanceInClusterResponse;
class DescribePolicyInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceName: 'instance_name',
            policyName: 'policy_name',
        };
    }
    static types() {
        return {
            instanceName: 'string',
            policyName: 'string',
        };
    }
}
exports.DescribePolicyInstancesRequest = DescribePolicyInstancesRequest;
class DescribePolicyInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribePolicyInstancesResponseBody },
        };
    }
}
exports.DescribePolicyInstancesResponse = DescribePolicyInstancesResponse;
class DescribePolicyInstancesStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instancesSeverityCount: 'instances_severity_count',
            policyInstances: 'policy_instances',
        };
    }
    static types() {
        return {
            instancesSeverityCount: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            policyInstances: { 'type': 'array', 'itemType': DescribePolicyInstancesStatusResponseBodyPolicyInstances },
        };
    }
}
exports.DescribePolicyInstancesStatusResponseBody = DescribePolicyInstancesStatusResponseBody;
class DescribePolicyInstancesStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribePolicyInstancesStatusResponseBody,
        };
    }
}
exports.DescribePolicyInstancesStatusResponse = DescribePolicyInstancesStatusResponse;
class DescribeTaskInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            created: 'created',
            currentStage: 'current_stage',
            error: 'error',
            events: 'events',
            parameters: 'parameters',
            stages: 'stages',
            state: 'state',
            target: 'target',
            taskId: 'task_id',
            taskResult: 'task_result',
            taskType: 'task_type',
            updated: 'updated',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            created: 'string',
            currentStage: 'string',
            error: DescribeTaskInfoResponseBodyError,
            events: { 'type': 'array', 'itemType': DescribeTaskInfoResponseBodyEvents },
            parameters: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            stages: { 'type': 'array', 'itemType': DescribeTaskInfoResponseBodyStages },
            state: 'string',
            target: DescribeTaskInfoResponseBodyTarget,
            taskId: 'string',
            taskResult: { 'type': 'array', 'itemType': DescribeTaskInfoResponseBodyTaskResult },
            taskType: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeTaskInfoResponseBody = DescribeTaskInfoResponseBody;
class DescribeTaskInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeTaskInfoResponseBody,
        };
    }
}
exports.DescribeTaskInfoResponse = DescribeTaskInfoResponse;
class DescribeTemplateAttributeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            templateType: 'template_type',
        };
    }
    static types() {
        return {
            templateType: 'string',
        };
    }
}
exports.DescribeTemplateAttributeRequest = DescribeTemplateAttributeRequest;
class DescribeTemplateAttributeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeTemplateAttributeResponseBody },
        };
    }
}
exports.DescribeTemplateAttributeResponse = DescribeTemplateAttributeResponse;
class DescribeTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNum: 'page_num',
            pageSize: 'page_size',
            templateType: 'template_type',
        };
    }
    static types() {
        return {
            pageNum: 'number',
            pageSize: 'number',
            templateType: 'string',
        };
    }
}
exports.DescribeTemplatesRequest = DescribeTemplatesRequest;
class DescribeTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageInfo: 'page_info',
            templates: 'templates',
        };
    }
    static types() {
        return {
            pageInfo: DescribeTemplatesResponseBodyPageInfo,
            templates: { 'type': 'array', 'itemType': DescribeTemplatesResponseBodyTemplates },
        };
    }
}
exports.DescribeTemplatesResponseBody = DescribeTemplatesResponseBody;
class DescribeTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeTemplatesResponseBody,
        };
    }
}
exports.DescribeTemplatesResponse = DescribeTemplatesResponse;
class DescribeTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            namespace: 'Namespace',
            type: 'Type',
            action: 'action',
        };
    }
    static types() {
        return {
            name: 'string',
            namespace: 'string',
            type: 'string',
            action: 'string',
        };
    }
}
exports.DescribeTriggerRequest = DescribeTriggerRequest;
class DescribeTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeTriggerResponseBody },
        };
    }
}
exports.DescribeTriggerResponse = DescribeTriggerResponse;
class DescribeUserPermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': DescribeUserPermissionResponseBody },
        };
    }
}
exports.DescribeUserPermissionResponse = DescribeUserPermissionResponse;
class DescribeUserQuotaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amkClusterQuota: 'amk_cluster_quota',
            askClusterQuota: 'ask_cluster_quota',
            clusterNodepoolQuota: 'cluster_nodepool_quota',
            clusterQuota: 'cluster_quota',
            edgeImprovedNodepoolQuota: 'edge_improved_nodepool_quota',
            nodeQuota: 'node_quota',
        };
    }
    static types() {
        return {
            amkClusterQuota: 'number',
            askClusterQuota: 'number',
            clusterNodepoolQuota: 'number',
            clusterQuota: 'number',
            edgeImprovedNodepoolQuota: DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota,
            nodeQuota: 'number',
        };
    }
}
exports.DescribeUserQuotaResponseBody = DescribeUserQuotaResponseBody;
class DescribeUserQuotaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeUserQuotaResponseBody,
        };
    }
}
exports.DescribeUserQuotaResponse = DescribeUserQuotaResponse;
class DescribeWorkflowsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobs: 'jobs',
        };
    }
    static types() {
        return {
            jobs: { 'type': 'array', 'itemType': DescribeWorkflowsResponseBodyJobs },
        };
    }
}
exports.DescribeWorkflowsResponseBody = DescribeWorkflowsResponseBody;
class DescribeWorkflowsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeWorkflowsResponseBody,
        };
    }
}
exports.DescribeWorkflowsResponse = DescribeWorkflowsResponse;
class EdgeClusterAddEdgeMachineRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expired: 'expired',
            nodepoolId: 'nodepool_id',
            options: 'options',
        };
    }
    static types() {
        return {
            expired: 'number',
            nodepoolId: 'string',
            options: 'string',
        };
    }
}
exports.EdgeClusterAddEdgeMachineRequest = EdgeClusterAddEdgeMachineRequest;
class EdgeClusterAddEdgeMachineResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            edgeMachineId: 'edge_machine_id',
            requestId: 'request_id',
        };
    }
    static types() {
        return {
            edgeMachineId: 'string',
            requestId: 'string',
        };
    }
}
exports.EdgeClusterAddEdgeMachineResponseBody = EdgeClusterAddEdgeMachineResponseBody;
class EdgeClusterAddEdgeMachineResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EdgeClusterAddEdgeMachineResponseBody,
        };
    }
}
exports.EdgeClusterAddEdgeMachineResponse = EdgeClusterAddEdgeMachineResponse;
class FixNodePoolVulsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodes: 'nodes',
            rolloutPolicy: 'rollout_policy',
            vulList: 'vul_list',
        };
    }
    static types() {
        return {
            nodes: { 'type': 'array', 'itemType': 'string' },
            rolloutPolicy: FixNodePoolVulsRequestRolloutPolicy,
            vulList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.FixNodePoolVulsRequest = FixNodePoolVulsRequest;
class FixNodePoolVulsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            taskId: 'string',
        };
    }
}
exports.FixNodePoolVulsResponseBody = FixNodePoolVulsResponseBody;
class FixNodePoolVulsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: FixNodePoolVulsResponseBody,
        };
    }
}
exports.FixNodePoolVulsResponse = FixNodePoolVulsResponse;
class GetKubernetesTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            namespace: 'Namespace',
            type: 'Type',
            action: 'action',
        };
    }
    static types() {
        return {
            name: 'string',
            namespace: 'string',
            type: 'string',
            action: 'string',
        };
    }
}
exports.GetKubernetesTriggerRequest = GetKubernetesTriggerRequest;
class GetKubernetesTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: { 'type': 'array', 'itemType': GetKubernetesTriggerResponseBody },
        };
    }
}
exports.GetKubernetesTriggerResponse = GetKubernetesTriggerResponse;
class GetUpgradeStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorMessage: 'error_message',
            precheckReportId: 'precheck_report_id',
            status: 'status',
            upgradeStep: 'upgrade_step',
            upgradeTask: 'upgrade_task',
        };
    }
    static types() {
        return {
            errorMessage: 'string',
            precheckReportId: 'string',
            status: 'string',
            upgradeStep: 'string',
            upgradeTask: GetUpgradeStatusResponseBodyUpgradeTask,
        };
    }
}
exports.GetUpgradeStatusResponseBody = GetUpgradeStatusResponseBody;
class GetUpgradeStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUpgradeStatusResponseBody,
        };
    }
}
exports.GetUpgradeStatusResponse = GetUpgradeStatusResponse;
class GrantPermissionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': GrantPermissionsRequestBody },
        };
    }
}
exports.GrantPermissionsRequest = GrantPermissionsRequest;
class GrantPermissionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.GrantPermissionsResponse = GrantPermissionsResponse;
class InstallClusterAddonsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': InstallClusterAddonsRequestBody },
        };
    }
}
exports.InstallClusterAddonsRequest = InstallClusterAddonsRequest;
class InstallClusterAddonsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.InstallClusterAddonsResponse = InstallClusterAddonsResponse;
class ListTagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'next_token',
            regionId: 'region_id',
            resourceIds: 'resource_ids',
            resourceType: 'resource_type',
            tags: 'tags',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            regionId: 'string',
            resourceIds: { 'type': 'array', 'itemType': 'string' },
            resourceType: 'string',
            tags: { 'type': 'array', 'itemType': Tag },
        };
    }
}
exports.ListTagResourcesRequest = ListTagResourcesRequest;
class ListTagResourcesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'next_token',
            regionId: 'region_id',
            resourceIdsShrink: 'resource_ids',
            resourceType: 'resource_type',
            tagsShrink: 'tags',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            regionId: 'string',
            resourceIdsShrink: 'string',
            resourceType: 'string',
            tagsShrink: 'string',
        };
    }
}
exports.ListTagResourcesShrinkRequest = ListTagResourcesShrinkRequest;
class ListTagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'next_token',
            requestId: 'request_id',
            tagResources: 'tag_resources',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            requestId: 'string',
            tagResources: ListTagResourcesResponseBodyTagResources,
        };
    }
}
exports.ListTagResourcesResponseBody = ListTagResourcesResponseBody;
class ListTagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTagResourcesResponseBody,
        };
    }
}
exports.ListTagResourcesResponse = ListTagResourcesResponse;
class MigrateClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ossBucketEndpoint: 'oss_bucket_endpoint',
            ossBucketName: 'oss_bucket_name',
        };
    }
    static types() {
        return {
            ossBucketEndpoint: 'string',
            ossBucketName: 'string',
        };
    }
}
exports.MigrateClusterRequest = MigrateClusterRequest;
class MigrateClusterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.MigrateClusterResponseBody = MigrateClusterResponseBody;
class MigrateClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MigrateClusterResponseBody,
        };
    }
}
exports.MigrateClusterResponse = MigrateClusterResponse;
class ModifyClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiServerEip: 'api_server_eip',
            apiServerEipId: 'api_server_eip_id',
            deletionProtection: 'deletion_protection',
            enableRrsa: 'enable_rrsa',
            ingressDomainRebinding: 'ingress_domain_rebinding',
            ingressLoadbalancerId: 'ingress_loadbalancer_id',
            instanceDeletionProtection: 'instance_deletion_protection',
            maintenanceWindow: 'maintenance_window',
            resourceGroupId: 'resource_group_id',
        };
    }
    static types() {
        return {
            apiServerEip: 'boolean',
            apiServerEipId: 'string',
            deletionProtection: 'boolean',
            enableRrsa: 'boolean',
            ingressDomainRebinding: 'string',
            ingressLoadbalancerId: 'string',
            instanceDeletionProtection: 'boolean',
            maintenanceWindow: MaintenanceWindow,
            resourceGroupId: 'string',
        };
    }
}
exports.ModifyClusterRequest = ModifyClusterRequest;
class ModifyClusterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyClusterResponseBody = ModifyClusterResponseBody;
class ModifyClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyClusterResponseBody,
        };
    }
}
exports.ModifyClusterResponse = ModifyClusterResponse;
class ModifyClusterAddonRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'config',
        };
    }
    static types() {
        return {
            config: 'string',
        };
    }
}
exports.ModifyClusterAddonRequest = ModifyClusterAddonRequest;
class ModifyClusterAddonResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.ModifyClusterAddonResponse = ModifyClusterAddonResponse;
class ModifyClusterConfigurationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customizeConfig: 'customize_config',
        };
    }
    static types() {
        return {
            customizeConfig: { 'type': 'array', 'itemType': ModifyClusterConfigurationRequestCustomizeConfig },
        };
    }
}
exports.ModifyClusterConfigurationRequest = ModifyClusterConfigurationRequest;
class ModifyClusterConfigurationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.ModifyClusterConfigurationResponse = ModifyClusterConfigurationResponse;
class ModifyClusterNodePoolRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoScaling: 'auto_scaling',
            kubernetesConfig: 'kubernetes_config',
            management: 'management',
            nodepoolInfo: 'nodepool_info',
            scalingGroup: 'scaling_group',
            teeConfig: 'tee_config',
            updateNodes: 'update_nodes',
        };
    }
    static types() {
        return {
            autoScaling: ModifyClusterNodePoolRequestAutoScaling,
            kubernetesConfig: ModifyClusterNodePoolRequestKubernetesConfig,
            management: ModifyClusterNodePoolRequestManagement,
            nodepoolInfo: ModifyClusterNodePoolRequestNodepoolInfo,
            scalingGroup: ModifyClusterNodePoolRequestScalingGroup,
            teeConfig: ModifyClusterNodePoolRequestTeeConfig,
            updateNodes: 'boolean',
        };
    }
}
exports.ModifyClusterNodePoolRequest = ModifyClusterNodePoolRequest;
class ModifyClusterNodePoolResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodepoolId: 'nodepool_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            nodepoolId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyClusterNodePoolResponseBody = ModifyClusterNodePoolResponseBody;
class ModifyClusterNodePoolResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyClusterNodePoolResponseBody,
        };
    }
}
exports.ModifyClusterNodePoolResponse = ModifyClusterNodePoolResponse;
class ModifyClusterTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': Tag },
        };
    }
}
exports.ModifyClusterTagsRequest = ModifyClusterTagsRequest;
class ModifyClusterTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.ModifyClusterTagsResponse = ModifyClusterTagsResponse;
class ModifyNodePoolNodeConfigRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            kubeletConfig: 'kubelet_config',
            rollingPolicy: 'rolling_policy',
        };
    }
    static types() {
        return {
            kubeletConfig: ModifyNodePoolNodeConfigRequestKubeletConfig,
            rollingPolicy: ModifyNodePoolNodeConfigRequestRollingPolicy,
        };
    }
}
exports.ModifyNodePoolNodeConfigRequest = ModifyNodePoolNodeConfigRequest;
class ModifyNodePoolNodeConfigResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodepoolId: 'nodepool_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            nodepoolId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ModifyNodePoolNodeConfigResponseBody = ModifyNodePoolNodeConfigResponseBody;
class ModifyNodePoolNodeConfigResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyNodePoolNodeConfigResponseBody,
        };
    }
}
exports.ModifyNodePoolNodeConfigResponse = ModifyNodePoolNodeConfigResponse;
class ModifyPolicyInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            instanceName: 'instance_name',
            namespaces: 'namespaces',
            parameters: 'parameters',
        };
    }
    static types() {
        return {
            action: 'string',
            instanceName: 'string',
            namespaces: { 'type': 'array', 'itemType': 'string' },
            parameters: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.ModifyPolicyInstanceRequest = ModifyPolicyInstanceRequest;
class ModifyPolicyInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instances: 'instances',
        };
    }
    static types() {
        return {
            instances: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ModifyPolicyInstanceResponseBody = ModifyPolicyInstanceResponseBody;
class ModifyPolicyInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyPolicyInstanceResponseBody,
        };
    }
}
exports.ModifyPolicyInstanceResponse = ModifyPolicyInstanceResponse;
class OpenAckServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
}
exports.OpenAckServiceRequest = OpenAckServiceRequest;
class OpenAckServiceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderId: 'order_id',
            requestId: 'request_id',
        };
    }
    static types() {
        return {
            orderId: 'string',
            requestId: 'string',
        };
    }
}
exports.OpenAckServiceResponseBody = OpenAckServiceResponseBody;
class OpenAckServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenAckServiceResponseBody,
        };
    }
}
exports.OpenAckServiceResponse = OpenAckServiceResponse;
class PauseClusterUpgradeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.PauseClusterUpgradeResponse = PauseClusterUpgradeResponse;
class PauseComponentUpgradeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.PauseComponentUpgradeResponse = PauseComponentUpgradeResponse;
class PauseTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.PauseTaskResponse = PauseTaskResponse;
class RemoveClusterNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            drainNode: 'drain_node',
            nodes: 'nodes',
            releaseNode: 'release_node',
        };
    }
    static types() {
        return {
            drainNode: 'boolean',
            nodes: { 'type': 'array', 'itemType': 'string' },
            releaseNode: 'boolean',
        };
    }
}
exports.RemoveClusterNodesRequest = RemoveClusterNodesRequest;
class RemoveClusterNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.RemoveClusterNodesResponse = RemoveClusterNodesResponse;
class RemoveNodePoolNodesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            drainNode: 'drain_node',
            nodes: 'nodes',
            releaseNode: 'release_node',
        };
    }
    static types() {
        return {
            drainNode: 'boolean',
            nodes: { 'type': 'array', 'itemType': 'string' },
            releaseNode: 'boolean',
        };
    }
}
exports.RemoveNodePoolNodesRequest = RemoveNodePoolNodesRequest;
class RemoveNodePoolNodesShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            drainNode: 'drain_node',
            nodesShrink: 'nodes',
            releaseNode: 'release_node',
        };
    }
    static types() {
        return {
            drainNode: 'boolean',
            nodesShrink: 'string',
            releaseNode: 'boolean',
        };
    }
}
exports.RemoveNodePoolNodesShrinkRequest = RemoveNodePoolNodesShrinkRequest;
class RemoveNodePoolNodesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.RemoveNodePoolNodesResponseBody = RemoveNodePoolNodesResponseBody;
class RemoveNodePoolNodesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveNodePoolNodesResponseBody,
        };
    }
}
exports.RemoveNodePoolNodesResponse = RemoveNodePoolNodesResponse;
class RemoveWorkflowResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.RemoveWorkflowResponse = RemoveWorkflowResponse;
class RepairClusterNodePoolRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nodes: 'nodes',
        };
    }
    static types() {
        return {
            nodes: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RepairClusterNodePoolRequest = RepairClusterNodePoolRequest;
class RepairClusterNodePoolResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.RepairClusterNodePoolResponseBody = RepairClusterNodePoolResponseBody;
class RepairClusterNodePoolResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RepairClusterNodePoolResponseBody,
        };
    }
}
exports.RepairClusterNodePoolResponse = RepairClusterNodePoolResponse;
class ResumeComponentUpgradeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.ResumeComponentUpgradeResponse = ResumeComponentUpgradeResponse;
class ResumeTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.ResumeTaskResponse = ResumeTaskResponse;
class ResumeUpgradeClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.ResumeUpgradeClusterResponse = ResumeUpgradeClusterResponse;
class ScaleClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cloudMonitorFlags: 'cloud_monitor_flags',
            count: 'count',
            cpuPolicy: 'cpu_policy',
            disableRollback: 'disable_rollback',
            keyPair: 'key_pair',
            loginPassword: 'login_password',
            tags: 'tags',
            taints: 'taints',
            vswitchIds: 'vswitch_ids',
            workerAutoRenew: 'worker_auto_renew',
            workerAutoRenewPeriod: 'worker_auto_renew_period',
            workerDataDisk: 'worker_data_disk',
            workerDataDisks: 'worker_data_disks',
            workerInstanceChargeType: 'worker_instance_charge_type',
            workerInstanceTypes: 'worker_instance_types',
            workerPeriod: 'worker_period',
            workerPeriodUnit: 'worker_period_unit',
            workerSystemDiskCategory: 'worker_system_disk_category',
            workerSystemDiskSize: 'worker_system_disk_size',
        };
    }
    static types() {
        return {
            cloudMonitorFlags: 'boolean',
            count: 'number',
            cpuPolicy: 'string',
            disableRollback: 'boolean',
            keyPair: 'string',
            loginPassword: 'string',
            tags: { 'type': 'array', 'itemType': ScaleClusterRequestTags },
            taints: { 'type': 'array', 'itemType': ScaleClusterRequestTaints },
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
            workerAutoRenew: 'boolean',
            workerAutoRenewPeriod: 'number',
            workerDataDisk: 'boolean',
            workerDataDisks: { 'type': 'array', 'itemType': ScaleClusterRequestWorkerDataDisks },
            workerInstanceChargeType: 'string',
            workerInstanceTypes: { 'type': 'array', 'itemType': 'string' },
            workerPeriod: 'number',
            workerPeriodUnit: 'string',
            workerSystemDiskCategory: 'string',
            workerSystemDiskSize: 'number',
        };
    }
}
exports.ScaleClusterRequest = ScaleClusterRequest;
class ScaleClusterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ScaleClusterResponseBody = ScaleClusterResponseBody;
class ScaleClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ScaleClusterResponseBody,
        };
    }
}
exports.ScaleClusterResponse = ScaleClusterResponse;
class ScaleClusterNodePoolRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            count: 'count',
        };
    }
    static types() {
        return {
            count: 'number',
        };
    }
}
exports.ScaleClusterNodePoolRequest = ScaleClusterNodePoolRequest;
class ScaleClusterNodePoolResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            taskId: 'string',
        };
    }
}
exports.ScaleClusterNodePoolResponseBody = ScaleClusterNodePoolResponseBody;
class ScaleClusterNodePoolResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ScaleClusterNodePoolResponseBody,
        };
    }
}
exports.ScaleClusterNodePoolResponse = ScaleClusterNodePoolResponse;
class ScaleOutClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cloudMonitorFlags: 'cloud_monitor_flags',
            count: 'count',
            cpuPolicy: 'cpu_policy',
            imageId: 'image_id',
            keyPair: 'key_pair',
            loginPassword: 'login_password',
            rdsInstances: 'rds_instances',
            runtime: 'runtime',
            tags: 'tags',
            taints: 'taints',
            userData: 'user_data',
            vswitchIds: 'vswitch_ids',
            workerAutoRenew: 'worker_auto_renew',
            workerAutoRenewPeriod: 'worker_auto_renew_period',
            workerDataDisks: 'worker_data_disks',
            workerInstanceChargeType: 'worker_instance_charge_type',
            workerInstanceTypes: 'worker_instance_types',
            workerPeriod: 'worker_period',
            workerPeriodUnit: 'worker_period_unit',
            workerSystemDiskCategory: 'worker_system_disk_category',
            workerSystemDiskSize: 'worker_system_disk_size',
        };
    }
    static types() {
        return {
            cloudMonitorFlags: 'boolean',
            count: 'number',
            cpuPolicy: 'string',
            imageId: 'string',
            keyPair: 'string',
            loginPassword: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            runtime: Runtime,
            tags: { 'type': 'array', 'itemType': Tag },
            taints: { 'type': 'array', 'itemType': Taint },
            userData: 'string',
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
            workerAutoRenew: 'boolean',
            workerAutoRenewPeriod: 'number',
            workerDataDisks: { 'type': 'array', 'itemType': ScaleOutClusterRequestWorkerDataDisks },
            workerInstanceChargeType: 'string',
            workerInstanceTypes: { 'type': 'array', 'itemType': 'string' },
            workerPeriod: 'number',
            workerPeriodUnit: 'string',
            workerSystemDiskCategory: 'string',
            workerSystemDiskSize: 'number',
        };
    }
}
exports.ScaleOutClusterRequest = ScaleOutClusterRequest;
class ScaleOutClusterResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            requestId: 'request_id',
            taskId: 'task_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            requestId: 'string',
            taskId: 'string',
        };
    }
}
exports.ScaleOutClusterResponseBody = ScaleOutClusterResponseBody;
class ScaleOutClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ScaleOutClusterResponseBody,
        };
    }
}
exports.ScaleOutClusterResponse = ScaleOutClusterResponse;
class StartWorkflowRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mappingBamOutFilename: 'mapping_bam_out_filename',
            mappingBamOutPath: 'mapping_bam_out_path',
            mappingBucketName: 'mapping_bucket_name',
            mappingFastqFirstFilename: 'mapping_fastq_first_filename',
            mappingFastqPath: 'mapping_fastq_path',
            mappingFastqSecondFilename: 'mapping_fastq_second_filename',
            mappingIsMarkDup: 'mapping_is_mark_dup',
            mappingOssRegion: 'mapping_oss_region',
            mappingReferencePath: 'mapping_reference_path',
            service: 'service',
            wgsBucketName: 'wgs_bucket_name',
            wgsFastqFirstFilename: 'wgs_fastq_first_filename',
            wgsFastqPath: 'wgs_fastq_path',
            wgsFastqSecondFilename: 'wgs_fastq_second_filename',
            wgsOssRegion: 'wgs_oss_region',
            wgsReferencePath: 'wgs_reference_path',
            wgsVcfOutFilename: 'wgs_vcf_out_filename',
            wgsVcfOutPath: 'wgs_vcf_out_path',
            workflowType: 'workflow_type',
        };
    }
    static types() {
        return {
            mappingBamOutFilename: 'string',
            mappingBamOutPath: 'string',
            mappingBucketName: 'string',
            mappingFastqFirstFilename: 'string',
            mappingFastqPath: 'string',
            mappingFastqSecondFilename: 'string',
            mappingIsMarkDup: 'string',
            mappingOssRegion: 'string',
            mappingReferencePath: 'string',
            service: 'string',
            wgsBucketName: 'string',
            wgsFastqFirstFilename: 'string',
            wgsFastqPath: 'string',
            wgsFastqSecondFilename: 'string',
            wgsOssRegion: 'string',
            wgsReferencePath: 'string',
            wgsVcfOutFilename: 'string',
            wgsVcfOutPath: 'string',
            workflowType: 'string',
        };
    }
}
exports.StartWorkflowRequest = StartWorkflowRequest;
class StartWorkflowResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobName: 'JobName',
        };
    }
    static types() {
        return {
            jobName: 'string',
        };
    }
}
exports.StartWorkflowResponseBody = StartWorkflowResponseBody;
class StartWorkflowResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartWorkflowResponseBody,
        };
    }
}
exports.StartWorkflowResponse = StartWorkflowResponse;
class TagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            regionId: 'region_id',
            resourceIds: 'resource_ids',
            resourceType: 'resource_type',
            tags: 'tags',
        };
    }
    static types() {
        return {
            regionId: 'string',
            resourceIds: { 'type': 'array', 'itemType': 'string' },
            resourceType: 'string',
            tags: { 'type': 'array', 'itemType': Tag },
        };
    }
}
exports.TagResourcesRequest = TagResourcesRequest;
class TagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.TagResourcesResponseBody = TagResourcesResponseBody;
class TagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TagResourcesResponseBody,
        };
    }
}
exports.TagResourcesResponse = TagResourcesResponse;
class UnInstallClusterAddonsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addons: 'addons',
        };
    }
    static types() {
        return {
            addons: { 'type': 'array', 'itemType': UnInstallClusterAddonsRequestAddons },
        };
    }
}
exports.UnInstallClusterAddonsRequest = UnInstallClusterAddonsRequest;
class UnInstallClusterAddonsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UnInstallClusterAddonsResponse = UnInstallClusterAddonsResponse;
class UntagResourcesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            all: 'all',
            regionId: 'region_id',
            resourceIds: 'resource_ids',
            resourceType: 'resource_type',
            tagKeys: 'tag_keys',
        };
    }
    static types() {
        return {
            all: 'boolean',
            regionId: 'string',
            resourceIds: { 'type': 'array', 'itemType': 'string' },
            resourceType: 'string',
            tagKeys: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UntagResourcesRequest = UntagResourcesRequest;
class UntagResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.UntagResourcesResponseBody = UntagResourcesResponseBody;
class UntagResourcesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UntagResourcesResponseBody,
        };
    }
}
exports.UntagResourcesResponse = UntagResourcesResponse;
class UpdateContactGroupForAlertResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UpdateContactGroupForAlertResponse = UpdateContactGroupForAlertResponse;
class UpdateK8sClusterUserConfigExpireRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expireHour: 'expire_hour',
            user: 'user',
        };
    }
    static types() {
        return {
            expireHour: 'number',
            user: 'string',
        };
    }
}
exports.UpdateK8sClusterUserConfigExpireRequest = UpdateK8sClusterUserConfigExpireRequest;
class UpdateK8sClusterUserConfigExpireResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UpdateK8sClusterUserConfigExpireResponse = UpdateK8sClusterUserConfigExpireResponse;
class UpdateTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            name: 'name',
            tags: 'tags',
            template: 'template',
            templateType: 'template_type',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            tags: 'string',
            template: 'string',
            templateType: 'string',
        };
    }
}
exports.UpdateTemplateRequest = UpdateTemplateRequest;
class UpdateTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UpdateTemplateResponse = UpdateTemplateResponse;
class UpgradeClusterRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'component_name',
            nextVersion: 'next_version',
            version: 'version',
        };
    }
    static types() {
        return {
            componentName: 'string',
            nextVersion: 'string',
            version: 'string',
        };
    }
}
exports.UpgradeClusterRequest = UpgradeClusterRequest;
class UpgradeClusterResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UpgradeClusterResponse = UpgradeClusterResponse;
class UpgradeClusterAddonsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': UpgradeClusterAddonsRequestBody },
        };
    }
}
exports.UpgradeClusterAddonsRequest = UpgradeClusterAddonsRequest;
class UpgradeClusterAddonsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UpgradeClusterAddonsResponse = UpgradeClusterAddonsResponse;
class UpgradeClusterNodepoolRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageId: 'image_id',
            kubernetesVersion: 'kubernetes_version',
            runtimeVersion: 'runtime_version',
        };
    }
    static types() {
        return {
            imageId: 'string',
            kubernetesVersion: 'string',
            runtimeVersion: 'string',
        };
    }
}
exports.UpgradeClusterNodepoolRequest = UpgradeClusterNodepoolRequest;
class UpgradeClusterNodepoolResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'RequestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.UpgradeClusterNodepoolResponseBody = UpgradeClusterNodepoolResponseBody;
class UpgradeClusterNodepoolResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpgradeClusterNodepoolResponseBody,
        };
    }
}
exports.UpgradeClusterNodepoolResponse = UpgradeClusterNodepoolResponse;
class AttachInstancesResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            instanceId: 'instanceId',
            message: 'message',
        };
    }
    static types() {
        return {
            code: 'string',
            instanceId: 'string',
            message: 'string',
        };
    }
}
exports.AttachInstancesResponseBodyList = AttachInstancesResponseBodyList;
class CreateClusterRequestWorkerDataDisks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'category',
            encrypted: 'encrypted',
            performanceLevel: 'performance_level',
            size: 'size',
        };
    }
    static types() {
        return {
            category: 'string',
            encrypted: 'string',
            performanceLevel: 'string',
            size: 'string',
        };
    }
}
exports.CreateClusterRequestWorkerDataDisks = CreateClusterRequestWorkerDataDisks;
class CreateClusterNodePoolRequestAutoScaling extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eipBandwidth: 'eip_bandwidth',
            eipInternetChargeType: 'eip_internet_charge_type',
            enable: 'enable',
            isBondEip: 'is_bond_eip',
            maxInstances: 'max_instances',
            minInstances: 'min_instances',
            type: 'type',
        };
    }
    static types() {
        return {
            eipBandwidth: 'number',
            eipInternetChargeType: 'string',
            enable: 'boolean',
            isBondEip: 'boolean',
            maxInstances: 'number',
            minInstances: 'number',
            type: 'string',
        };
    }
}
exports.CreateClusterNodePoolRequestAutoScaling = CreateClusterNodePoolRequestAutoScaling;
class CreateClusterNodePoolRequestInterconnectConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bandwidth: 'bandwidth',
            ccnId: 'ccn_id',
            ccnRegionId: 'ccn_region_id',
            cenId: 'cen_id',
            improvedPeriod: 'improved_period',
        };
    }
    static types() {
        return {
            bandwidth: 'number',
            ccnId: 'string',
            ccnRegionId: 'string',
            cenId: 'string',
            improvedPeriod: 'string',
        };
    }
}
exports.CreateClusterNodePoolRequestInterconnectConfig = CreateClusterNodePoolRequestInterconnectConfig;
class CreateClusterNodePoolRequestKubernetesConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cmsEnabled: 'cms_enabled',
            cpuPolicy: 'cpu_policy',
            labels: 'labels',
            nodeNameMode: 'node_name_mode',
            runtime: 'runtime',
            runtimeVersion: 'runtime_version',
            taints: 'taints',
            userData: 'user_data',
        };
    }
    static types() {
        return {
            cmsEnabled: 'boolean',
            cpuPolicy: 'string',
            labels: { 'type': 'array', 'itemType': Tag },
            nodeNameMode: 'string',
            runtime: 'string',
            runtimeVersion: 'string',
            taints: { 'type': 'array', 'itemType': Taint },
            userData: 'string',
        };
    }
}
exports.CreateClusterNodePoolRequestKubernetesConfig = CreateClusterNodePoolRequestKubernetesConfig;
class CreateClusterNodePoolRequestManagementUpgradeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUpgrade: 'auto_upgrade',
            maxUnavailable: 'max_unavailable',
            surge: 'surge',
            surgePercentage: 'surge_percentage',
        };
    }
    static types() {
        return {
            autoUpgrade: 'boolean',
            maxUnavailable: 'number',
            surge: 'number',
            surgePercentage: 'number',
        };
    }
}
exports.CreateClusterNodePoolRequestManagementUpgradeConfig = CreateClusterNodePoolRequestManagementUpgradeConfig;
class CreateClusterNodePoolRequestManagement extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRepair: 'auto_repair',
            enable: 'enable',
            upgradeConfig: 'upgrade_config',
        };
    }
    static types() {
        return {
            autoRepair: 'boolean',
            enable: 'boolean',
            upgradeConfig: CreateClusterNodePoolRequestManagementUpgradeConfig,
        };
    }
}
exports.CreateClusterNodePoolRequestManagement = CreateClusterNodePoolRequestManagement;
class CreateClusterNodePoolRequestNodepoolInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            resourceGroupId: 'resource_group_id',
            type: 'type',
        };
    }
    static types() {
        return {
            name: 'string',
            resourceGroupId: 'string',
            type: 'string',
        };
    }
}
exports.CreateClusterNodePoolRequestNodepoolInfo = CreateClusterNodePoolRequestNodepoolInfo;
class CreateClusterNodePoolRequestScalingGroupSpotPriceLimit extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceType: 'instance_type',
            priceLimit: 'price_limit',
        };
    }
    static types() {
        return {
            instanceType: 'string',
            priceLimit: 'string',
        };
    }
}
exports.CreateClusterNodePoolRequestScalingGroupSpotPriceLimit = CreateClusterNodePoolRequestScalingGroupSpotPriceLimit;
class CreateClusterNodePoolRequestScalingGroupTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateClusterNodePoolRequestScalingGroupTags = CreateClusterNodePoolRequestScalingGroupTags;
class CreateClusterNodePoolRequestScalingGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'auto_renew',
            autoRenewPeriod: 'auto_renew_period',
            compensateWithOnDemand: 'compensate_with_on_demand',
            dataDisks: 'data_disks',
            deploymentsetId: 'deploymentset_id',
            desiredSize: 'desired_size',
            imageId: 'image_id',
            imageType: 'image_type',
            instanceChargeType: 'instance_charge_type',
            instanceTypes: 'instance_types',
            internetChargeType: 'internet_charge_type',
            internetMaxBandwidthOut: 'internet_max_bandwidth_out',
            keyPair: 'key_pair',
            loginPassword: 'login_password',
            multiAzPolicy: 'multi_az_policy',
            onDemandBaseCapacity: 'on_demand_base_capacity',
            onDemandPercentageAboveBaseCapacity: 'on_demand_percentage_above_base_capacity',
            period: 'period',
            periodUnit: 'period_unit',
            platform: 'platform',
            rdsInstances: 'rds_instances',
            scalingPolicy: 'scaling_policy',
            securityGroupId: 'security_group_id',
            securityGroupIds: 'security_group_ids',
            spotInstancePools: 'spot_instance_pools',
            spotInstanceRemedy: 'spot_instance_remedy',
            spotPriceLimit: 'spot_price_limit',
            spotStrategy: 'spot_strategy',
            systemDiskCategory: 'system_disk_category',
            systemDiskPerformanceLevel: 'system_disk_performance_level',
            systemDiskSize: 'system_disk_size',
            tags: 'tags',
            vswitchIds: 'vswitch_ids',
        };
    }
    static types() {
        return {
            autoRenew: 'boolean',
            autoRenewPeriod: 'number',
            compensateWithOnDemand: 'boolean',
            dataDisks: { 'type': 'array', 'itemType': DataDisk },
            deploymentsetId: 'string',
            desiredSize: 'number',
            imageId: 'string',
            imageType: 'string',
            instanceChargeType: 'string',
            instanceTypes: { 'type': 'array', 'itemType': 'string' },
            internetChargeType: 'string',
            internetMaxBandwidthOut: 'number',
            keyPair: 'string',
            loginPassword: 'string',
            multiAzPolicy: 'string',
            onDemandBaseCapacity: 'number',
            onDemandPercentageAboveBaseCapacity: 'number',
            period: 'number',
            periodUnit: 'string',
            platform: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            scalingPolicy: 'string',
            securityGroupId: 'string',
            securityGroupIds: { 'type': 'array', 'itemType': 'string' },
            spotInstancePools: 'number',
            spotInstanceRemedy: 'boolean',
            spotPriceLimit: { 'type': 'array', 'itemType': CreateClusterNodePoolRequestScalingGroupSpotPriceLimit },
            spotStrategy: 'string',
            systemDiskCategory: 'string',
            systemDiskPerformanceLevel: 'string',
            systemDiskSize: 'number',
            tags: { 'type': 'array', 'itemType': CreateClusterNodePoolRequestScalingGroupTags },
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CreateClusterNodePoolRequestScalingGroup = CreateClusterNodePoolRequestScalingGroup;
class CreateClusterNodePoolRequestTeeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            teeEnable: 'tee_enable',
        };
    }
    static types() {
        return {
            teeEnable: 'boolean',
        };
    }
}
exports.CreateClusterNodePoolRequestTeeConfig = CreateClusterNodePoolRequestTeeConfig;
class DescribeAddonsResponseBodyComponentGroupsItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
        };
    }
    static types() {
        return {
            name: 'string',
        };
    }
}
exports.DescribeAddonsResponseBodyComponentGroupsItems = DescribeAddonsResponseBodyComponentGroupsItems;
class DescribeAddonsResponseBodyComponentGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupName: 'group_name',
            items: 'items',
        };
    }
    static types() {
        return {
            groupName: 'string',
            items: { 'type': 'array', 'itemType': DescribeAddonsResponseBodyComponentGroupsItems },
        };
    }
}
exports.DescribeAddonsResponseBodyComponentGroups = DescribeAddonsResponseBodyComponentGroups;
class DescribeClusterEventsResponseBodyEventsData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            level: 'level',
            message: 'message',
            reason: 'reason',
        };
    }
    static types() {
        return {
            level: 'string',
            message: 'string',
            reason: 'string',
        };
    }
}
exports.DescribeClusterEventsResponseBodyEventsData = DescribeClusterEventsResponseBodyEventsData;
class DescribeClusterEventsResponseBodyEvents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            data: 'data',
            eventId: 'event_id',
            source: 'source',
            subject: 'subject',
            time: 'time',
            type: 'type',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            data: DescribeClusterEventsResponseBodyEventsData,
            eventId: 'string',
            source: 'string',
            subject: 'string',
            time: 'string',
            type: 'string',
        };
    }
}
exports.DescribeClusterEventsResponseBodyEvents = DescribeClusterEventsResponseBodyEvents;
class DescribeClusterEventsResponseBodyPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeClusterEventsResponseBodyPageInfo = DescribeClusterEventsResponseBodyPageInfo;
class DescribeClusterLogsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ID: 'ID',
            clusterId: 'cluster_id',
            clusterLog: 'cluster_log',
            created: 'created',
            updated: 'updated',
        };
    }
    static types() {
        return {
            ID: 'number',
            clusterId: 'string',
            clusterLog: 'string',
            created: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeClusterLogsResponseBody = DescribeClusterLogsResponseBody;
class DescribeClusterNodePoolDetailResponseBodyAutoScaling extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eipBandwidth: 'eip_bandwidth',
            eipInternetChargeType: 'eip_internet_charge_type',
            enable: 'enable',
            isBondEip: 'is_bond_eip',
            maxInstances: 'max_instances',
            minInstances: 'min_instances',
            type: 'type',
        };
    }
    static types() {
        return {
            eipBandwidth: 'number',
            eipInternetChargeType: 'string',
            enable: 'boolean',
            isBondEip: 'boolean',
            maxInstances: 'number',
            minInstances: 'number',
            type: 'string',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyAutoScaling = DescribeClusterNodePoolDetailResponseBodyAutoScaling;
class DescribeClusterNodePoolDetailResponseBodyInterconnectConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bandwidth: 'bandwidth',
            ccnId: 'ccn_id',
            ccnRegionId: 'ccn_region_id',
            cenId: 'cen_id',
            improvedPeriod: 'improved_period',
        };
    }
    static types() {
        return {
            bandwidth: 'number',
            ccnId: 'string',
            ccnRegionId: 'string',
            cenId: 'string',
            improvedPeriod: 'string',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyInterconnectConfig = DescribeClusterNodePoolDetailResponseBodyInterconnectConfig;
class DescribeClusterNodePoolDetailResponseBodyKubernetesConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cmsEnabled: 'cms_enabled',
            cpuPolicy: 'cpu_policy',
            labels: 'labels',
            nodeNameMode: 'node_name_mode',
            runtime: 'runtime',
            runtimeVersion: 'runtime_version',
            taints: 'taints',
            userData: 'user_data',
        };
    }
    static types() {
        return {
            cmsEnabled: 'boolean',
            cpuPolicy: 'string',
            labels: { 'type': 'array', 'itemType': Tag },
            nodeNameMode: 'string',
            runtime: 'string',
            runtimeVersion: 'string',
            taints: { 'type': 'array', 'itemType': Taint },
            userData: 'string',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyKubernetesConfig = DescribeClusterNodePoolDetailResponseBodyKubernetesConfig;
class DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUpgrade: 'auto_upgrade',
            maxUnavailable: 'max_unavailable',
            surge: 'surge',
            surgePercentage: 'surge_percentage',
        };
    }
    static types() {
        return {
            autoUpgrade: 'boolean',
            maxUnavailable: 'number',
            surge: 'number',
            surgePercentage: 'number',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig = DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig;
class DescribeClusterNodePoolDetailResponseBodyManagement extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRepair: 'auto_repair',
            enable: 'enable',
            upgradeConfig: 'upgrade_config',
        };
    }
    static types() {
        return {
            autoRepair: 'boolean',
            enable: 'boolean',
            upgradeConfig: DescribeClusterNodePoolDetailResponseBodyManagementUpgradeConfig,
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyManagement = DescribeClusterNodePoolDetailResponseBodyManagement;
class DescribeClusterNodePoolDetailResponseBodyNodepoolInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            created: 'created',
            isDefault: 'is_default',
            name: 'name',
            nodepoolId: 'nodepool_id',
            regionId: 'region_id',
            resourceGroupId: 'resource_group_id',
            type: 'type',
            updated: 'updated',
        };
    }
    static types() {
        return {
            created: 'string',
            isDefault: 'boolean',
            name: 'string',
            nodepoolId: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            type: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyNodepoolInfo = DescribeClusterNodePoolDetailResponseBodyNodepoolInfo;
class DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceType: 'instance_type',
            priceLimit: 'price_limit',
        };
    }
    static types() {
        return {
            instanceType: 'string',
            priceLimit: 'string',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit = DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit;
class DescribeClusterNodePoolDetailResponseBodyScalingGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'auto_renew',
            autoRenewPeriod: 'auto_renew_period',
            compensateWithOnDemand: 'compensate_with_on_demand',
            dataDisks: 'data_disks',
            deploymentsetId: 'deploymentset_id',
            desiredSize: 'desired_size',
            imageId: 'image_id',
            instanceChargeType: 'instance_charge_type',
            instanceTypes: 'instance_types',
            internetChargeType: 'internet_charge_type',
            internetMaxBandwidthOut: 'internet_max_bandwidth_out',
            keyPair: 'key_pair',
            loginPassword: 'login_password',
            multiAzPolicy: 'multi_az_policy',
            onDemandBaseCapacity: 'on_demand_base_capacity',
            onDemandPercentageAboveBaseCapacity: 'on_demand_percentage_above_base_capacity',
            period: 'period',
            periodUnit: 'period_unit',
            platform: 'platform',
            ramPolicy: 'ram_policy',
            rdsInstances: 'rds_instances',
            scalingGroupId: 'scaling_group_id',
            scalingPolicy: 'scaling_policy',
            securityGroupId: 'security_group_id',
            securityGroupIds: 'security_group_ids',
            spotInstancePools: 'spot_instance_pools',
            spotInstanceRemedy: 'spot_instance_remedy',
            spotPriceLimit: 'spot_price_limit',
            spotStrategy: 'spot_strategy',
            systemDiskCategory: 'system_disk_category',
            systemDiskPerformanceLevel: 'system_disk_performance_level',
            systemDiskSize: 'system_disk_size',
            tags: 'tags',
            vswitchIds: 'vswitch_ids',
        };
    }
    static types() {
        return {
            autoRenew: 'boolean',
            autoRenewPeriod: 'number',
            compensateWithOnDemand: 'boolean',
            dataDisks: { 'type': 'array', 'itemType': DataDisk },
            deploymentsetId: 'string',
            desiredSize: 'number',
            imageId: 'string',
            instanceChargeType: 'string',
            instanceTypes: { 'type': 'array', 'itemType': 'string' },
            internetChargeType: 'string',
            internetMaxBandwidthOut: 'number',
            keyPair: 'string',
            loginPassword: 'string',
            multiAzPolicy: 'string',
            onDemandBaseCapacity: 'number',
            onDemandPercentageAboveBaseCapacity: 'number',
            period: 'number',
            periodUnit: 'string',
            platform: 'string',
            ramPolicy: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            scalingGroupId: 'string',
            scalingPolicy: 'string',
            securityGroupId: 'string',
            securityGroupIds: { 'type': 'array', 'itemType': 'string' },
            spotInstancePools: 'number',
            spotInstanceRemedy: 'boolean',
            spotPriceLimit: { 'type': 'array', 'itemType': DescribeClusterNodePoolDetailResponseBodyScalingGroupSpotPriceLimit },
            spotStrategy: 'string',
            systemDiskCategory: 'string',
            systemDiskPerformanceLevel: 'string',
            systemDiskSize: 'number',
            tags: { 'type': 'array', 'itemType': Tag },
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyScalingGroup = DescribeClusterNodePoolDetailResponseBodyScalingGroup;
class DescribeClusterNodePoolDetailResponseBodyStatus extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedNodes: 'failed_nodes',
            healthyNodes: 'healthy_nodes',
            initialNodes: 'initial_nodes',
            offlineNodes: 'offline_nodes',
            removingNodes: 'removing_nodes',
            servingNodes: 'serving_nodes',
            state: 'state',
            totalNodes: 'total_nodes',
        };
    }
    static types() {
        return {
            failedNodes: 'number',
            healthyNodes: 'number',
            initialNodes: 'number',
            offlineNodes: 'number',
            removingNodes: 'number',
            servingNodes: 'number',
            state: 'string',
            totalNodes: 'number',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyStatus = DescribeClusterNodePoolDetailResponseBodyStatus;
class DescribeClusterNodePoolDetailResponseBodyTeeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            teeEnable: 'tee_enable',
        };
    }
    static types() {
        return {
            teeEnable: 'boolean',
        };
    }
}
exports.DescribeClusterNodePoolDetailResponseBodyTeeConfig = DescribeClusterNodePoolDetailResponseBodyTeeConfig;
class DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eipBandwidth: 'eip_bandwidth',
            eipInternetChargeType: 'eip_internet_charge_type',
            enable: 'enable',
            isBondEip: 'is_bond_eip',
            maxInstances: 'max_instances',
            minInstances: 'min_instances',
            type: 'type',
        };
    }
    static types() {
        return {
            eipBandwidth: 'number',
            eipInternetChargeType: 'string',
            enable: 'boolean',
            isBondEip: 'boolean',
            maxInstances: 'number',
            minInstances: 'number',
            type: 'string',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling = DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling;
class DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bandwidth: 'bandwidth',
            ccnId: 'ccn_id',
            ccnRegionId: 'ccn_region_id',
            cenId: 'cen_id',
            improvedPeriod: 'improved_period',
        };
    }
    static types() {
        return {
            bandwidth: 'number',
            ccnId: 'string',
            ccnRegionId: 'string',
            cenId: 'string',
            improvedPeriod: 'string',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig = DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig;
class DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cmsEnabled: 'cms_enabled',
            cpuPolicy: 'cpu_policy',
            labels: 'labels',
            nodeNameMode: 'node_name_mode',
            runtime: 'runtime',
            runtimeVersion: 'runtime_version',
            taints: 'taints',
            userData: 'user_data',
        };
    }
    static types() {
        return {
            cmsEnabled: 'boolean',
            cpuPolicy: 'string',
            labels: { 'type': 'array', 'itemType': Tag },
            nodeNameMode: 'string',
            runtime: 'string',
            runtimeVersion: 'string',
            taints: { 'type': 'array', 'itemType': Taint },
            userData: 'string',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig = DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig;
class DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUpgrade: 'auto_upgrade',
            maxUnavailable: 'max_unavailable',
            surge: 'surge',
            surgePercentage: 'surge_percentage',
        };
    }
    static types() {
        return {
            autoUpgrade: 'boolean',
            maxUnavailable: 'number',
            surge: 'number',
            surgePercentage: 'number',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig = DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig;
class DescribeClusterNodePoolsResponseBodyNodepoolsManagement extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRepair: 'auto_repair',
            enable: 'enable',
            upgradeConfig: 'upgrade_config',
        };
    }
    static types() {
        return {
            autoRepair: 'boolean',
            enable: 'boolean',
            upgradeConfig: DescribeClusterNodePoolsResponseBodyNodepoolsManagementUpgradeConfig,
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsManagement = DescribeClusterNodePoolsResponseBodyNodepoolsManagement;
class DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            created: 'created',
            isDefault: 'is_default',
            name: 'name',
            nodepoolId: 'nodepool_id',
            regionId: 'region_id',
            resourceGroupId: 'resource_group_id',
            type: 'type',
            updated: 'updated',
        };
    }
    static types() {
        return {
            created: 'string',
            isDefault: 'boolean',
            name: 'string',
            nodepoolId: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            type: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo = DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo;
class DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceType: 'instance_type',
            priceLimit: 'price_limit',
        };
    }
    static types() {
        return {
            instanceType: 'string',
            priceLimit: 'string',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit = DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit;
class DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'auto_renew',
            autoRenewPeriod: 'auto_renew_period',
            compensateWithOnDemand: 'compensate_with_on_demand',
            dataDisks: 'data_disks',
            deploymentsetId: 'deploymentset_id',
            desiredSize: 'desired_size',
            imageId: 'image_id',
            instanceChargeType: 'instance_charge_type',
            instanceTypes: 'instance_types',
            internetChargeType: 'internet_charge_type',
            internetMaxBandwidthOut: 'internet_max_bandwidth_out',
            keyPair: 'key_pair',
            loginPassword: 'login_password',
            multiAzPolicy: 'multi_az_policy',
            onDemandBaseCapacity: 'on_demand_base_capacity',
            onDemandPercentageAboveBaseCapacity: 'on_demand_percentage_above_base_capacity',
            period: 'period',
            periodUnit: 'period_unit',
            platform: 'platform',
            ramPolicy: 'ram_policy',
            rdsInstances: 'rds_instances',
            scalingGroupId: 'scaling_group_id',
            scalingPolicy: 'scaling_policy',
            securityGroupId: 'security_group_id',
            securityGroupIds: 'security_group_ids',
            spotInstancePools: 'spot_instance_pools',
            spotInstanceRemedy: 'spot_instance_remedy',
            spotPriceLimit: 'spot_price_limit',
            spotStrategy: 'spot_strategy',
            systemDiskCategory: 'system_disk_category',
            systemDiskPerformanceLevel: 'system_disk_performance_level',
            systemDiskSize: 'system_disk_size',
            tags: 'tags',
            vswitchIds: 'vswitch_ids',
        };
    }
    static types() {
        return {
            autoRenew: 'boolean',
            autoRenewPeriod: 'number',
            compensateWithOnDemand: 'boolean',
            dataDisks: { 'type': 'array', 'itemType': DataDisk },
            deploymentsetId: 'string',
            desiredSize: 'number',
            imageId: 'string',
            instanceChargeType: 'string',
            instanceTypes: { 'type': 'array', 'itemType': 'string' },
            internetChargeType: 'string',
            internetMaxBandwidthOut: 'number',
            keyPair: 'string',
            loginPassword: 'string',
            multiAzPolicy: 'string',
            onDemandBaseCapacity: 'number',
            onDemandPercentageAboveBaseCapacity: 'number',
            period: 'number',
            periodUnit: 'string',
            platform: 'string',
            ramPolicy: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            scalingGroupId: 'string',
            scalingPolicy: 'string',
            securityGroupId: 'string',
            securityGroupIds: { 'type': 'array', 'itemType': 'string' },
            spotInstancePools: 'number',
            spotInstanceRemedy: 'boolean',
            spotPriceLimit: { 'type': 'array', 'itemType': DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroupSpotPriceLimit },
            spotStrategy: 'string',
            systemDiskCategory: 'string',
            systemDiskPerformanceLevel: 'string',
            systemDiskSize: 'number',
            tags: { 'type': 'array', 'itemType': Tag },
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup = DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup;
class DescribeClusterNodePoolsResponseBodyNodepoolsStatus extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedNodes: 'failed_nodes',
            healthyNodes: 'healthy_nodes',
            initialNodes: 'initial_nodes',
            offlineNodes: 'offline_nodes',
            removingNodes: 'removing_nodes',
            servingNodes: 'serving_nodes',
            state: 'state',
            totalNodes: 'total_nodes',
        };
    }
    static types() {
        return {
            failedNodes: 'number',
            healthyNodes: 'number',
            initialNodes: 'number',
            offlineNodes: 'number',
            removingNodes: 'number',
            servingNodes: 'number',
            state: 'string',
            totalNodes: 'number',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsStatus = DescribeClusterNodePoolsResponseBodyNodepoolsStatus;
class DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            teeEnable: 'tee_enable',
        };
    }
    static types() {
        return {
            teeEnable: 'boolean',
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig = DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig;
class DescribeClusterNodePoolsResponseBodyNodepools extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoScaling: 'auto_scaling',
            interconnectConfig: 'interconnect_config',
            interconnectMode: 'interconnect_mode',
            kubernetesConfig: 'kubernetes_config',
            management: 'management',
            maxNodes: 'max_nodes',
            nodepoolInfo: 'nodepool_info',
            scalingGroup: 'scaling_group',
            status: 'status',
            teeConfig: 'tee_config',
        };
    }
    static types() {
        return {
            autoScaling: DescribeClusterNodePoolsResponseBodyNodepoolsAutoScaling,
            interconnectConfig: DescribeClusterNodePoolsResponseBodyNodepoolsInterconnectConfig,
            interconnectMode: 'string',
            kubernetesConfig: DescribeClusterNodePoolsResponseBodyNodepoolsKubernetesConfig,
            management: DescribeClusterNodePoolsResponseBodyNodepoolsManagement,
            maxNodes: 'number',
            nodepoolInfo: DescribeClusterNodePoolsResponseBodyNodepoolsNodepoolInfo,
            scalingGroup: DescribeClusterNodePoolsResponseBodyNodepoolsScalingGroup,
            status: DescribeClusterNodePoolsResponseBodyNodepoolsStatus,
            teeConfig: DescribeClusterNodePoolsResponseBodyNodepoolsTeeConfig,
        };
    }
}
exports.DescribeClusterNodePoolsResponseBodyNodepools = DescribeClusterNodePoolsResponseBodyNodepools;
class DescribeClusterNodesResponseBodyNodes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creationTime: 'creation_time',
            errorMessage: 'error_message',
            expiredTime: 'expired_time',
            hostName: 'host_name',
            imageId: 'image_id',
            instanceChargeType: 'instance_charge_type',
            instanceId: 'instance_id',
            instanceName: 'instance_name',
            instanceRole: 'instance_role',
            instanceStatus: 'instance_status',
            instanceType: 'instance_type',
            instanceTypeFamily: 'instance_type_family',
            ipAddress: 'ip_address',
            isAliyunNode: 'is_aliyun_node',
            nodeName: 'node_name',
            nodeStatus: 'node_status',
            nodepoolId: 'nodepool_id',
            source: 'source',
            spotStrategy: 'spot_strategy',
            state: 'state',
        };
    }
    static types() {
        return {
            creationTime: 'string',
            errorMessage: 'string',
            expiredTime: 'string',
            hostName: 'string',
            imageId: 'string',
            instanceChargeType: 'string',
            instanceId: 'string',
            instanceName: 'string',
            instanceRole: 'string',
            instanceStatus: 'string',
            instanceType: 'string',
            instanceTypeFamily: 'string',
            ipAddress: { 'type': 'array', 'itemType': 'string' },
            isAliyunNode: 'boolean',
            nodeName: 'string',
            nodeStatus: 'string',
            nodepoolId: 'string',
            source: 'string',
            spotStrategy: 'string',
            state: 'string',
        };
    }
}
exports.DescribeClusterNodesResponseBodyNodes = DescribeClusterNodesResponseBodyNodes;
class DescribeClusterNodesResponseBodyPage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeClusterNodesResponseBodyPage = DescribeClusterNodesResponseBodyPage;
class DescribeClusterResourcesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            created: 'created',
            instanceId: 'instance_id',
            resourceInfo: 'resource_info',
            resourceType: 'resource_type',
            state: 'state',
            autoCreate: 'auto_create',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            created: 'string',
            instanceId: 'string',
            resourceInfo: 'string',
            resourceType: 'string',
            state: 'string',
            autoCreate: 'number',
        };
    }
}
exports.DescribeClusterResourcesResponseBody = DescribeClusterResourcesResponseBody;
class DescribeClusterTasksResponseBodyPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeClusterTasksResponseBodyPageInfo = DescribeClusterTasksResponseBodyPageInfo;
class DescribeClusterTasksResponseBodyTasksError extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            message: 'message',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
        };
    }
}
exports.DescribeClusterTasksResponseBodyTasksError = DescribeClusterTasksResponseBodyTasksError;
class DescribeClusterTasksResponseBodyTasks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            created: 'created',
            error: 'error',
            state: 'state',
            taskId: 'task_id',
            taskType: 'task_type',
            updated: 'updated',
        };
    }
    static types() {
        return {
            created: 'string',
            error: DescribeClusterTasksResponseBodyTasksError,
            state: 'string',
            taskId: 'string',
            taskType: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeClusterTasksResponseBodyTasks = DescribeClusterTasksResponseBodyTasks;
class DescribeClustersResponseBodyTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeClustersResponseBodyTags = DescribeClustersResponseBodyTags;
class DescribeClustersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            clusterType: 'cluster_type',
            created: 'created',
            currentVersion: 'current_version',
            dataDiskCategory: 'data_disk_category',
            dataDiskSize: 'data_disk_size',
            deletionProtection: 'deletion_protection',
            dockerVersion: 'docker_version',
            externalLoadbalancerId: 'external_loadbalancer_id',
            initVersion: 'init_version',
            masterUrl: 'master_url',
            metaData: 'meta_data',
            name: 'name',
            networkMode: 'network_mode',
            privateZone: 'private_zone',
            profile: 'profile',
            regionId: 'region_id',
            resourceGroupId: 'resource_group_id',
            securityGroupId: 'security_group_id',
            size: 'size',
            state: 'state',
            subnetCidr: 'subnet_cidr',
            tags: 'tags',
            updated: 'updated',
            vpcId: 'vpc_id',
            vswitchCidr: 'vswitch_cidr',
            vswitchId: 'vswitch_id',
            workerRamRoleName: 'worker_ram_role_name',
            zoneId: 'zone_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            clusterType: 'string',
            created: 'string',
            currentVersion: 'string',
            dataDiskCategory: 'string',
            dataDiskSize: 'number',
            deletionProtection: 'boolean',
            dockerVersion: 'string',
            externalLoadbalancerId: 'string',
            initVersion: 'string',
            masterUrl: 'string',
            metaData: 'string',
            name: 'string',
            networkMode: 'string',
            privateZone: 'boolean',
            profile: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            securityGroupId: 'string',
            size: 'number',
            state: 'string',
            subnetCidr: 'string',
            tags: { 'type': 'array', 'itemType': DescribeClustersResponseBodyTags },
            updated: 'string',
            vpcId: 'string',
            vswitchCidr: 'string',
            vswitchId: 'string',
            workerRamRoleName: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeClustersResponseBody = DescribeClustersResponseBody;
class DescribeClustersV1ResponseBodyClusters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            clusterSpec: 'cluster_spec',
            clusterType: 'cluster_type',
            created: 'created',
            currentVersion: 'current_version',
            deletionProtection: 'deletion_protection',
            dockerVersion: 'docker_version',
            externalLoadbalancerId: 'external_loadbalancer_id',
            initVersion: 'init_version',
            maintenanceWindow: 'maintenance_window',
            masterUrl: 'master_url',
            metaData: 'meta_data',
            name: 'name',
            networkMode: 'network_mode',
            nextVersion: 'next_version',
            privateZone: 'private_zone',
            profile: 'profile',
            regionId: 'region_id',
            resourceGroupId: 'resource_group_id',
            securityGroupId: 'security_group_id',
            size: 'size',
            state: 'state',
            subnetCidr: 'subnet_cidr',
            tags: 'tags',
            updated: 'updated',
            vpcId: 'vpc_id',
            vswitchId: 'vswitch_id',
            workerRamRoleName: 'worker_ram_role_name',
            zoneId: 'zone_id',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            clusterSpec: 'string',
            clusterType: 'string',
            created: 'string',
            currentVersion: 'string',
            deletionProtection: 'boolean',
            dockerVersion: 'string',
            externalLoadbalancerId: 'string',
            initVersion: 'string',
            maintenanceWindow: MaintenanceWindow,
            masterUrl: 'string',
            metaData: 'string',
            name: 'string',
            networkMode: 'string',
            nextVersion: 'string',
            privateZone: 'boolean',
            profile: 'string',
            regionId: 'string',
            resourceGroupId: 'string',
            securityGroupId: 'string',
            size: 'number',
            state: 'string',
            subnetCidr: 'string',
            tags: { 'type': 'array', 'itemType': Tag },
            updated: 'string',
            vpcId: 'string',
            vswitchId: 'string',
            workerRamRoleName: 'string',
            zoneId: 'string',
        };
    }
}
exports.DescribeClustersV1ResponseBodyClusters = DescribeClustersV1ResponseBodyClusters;
class DescribeClustersV1ResponseBodyPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeClustersV1ResponseBodyPageInfo = DescribeClustersV1ResponseBodyPageInfo;
class DescribeEdgeMachineModelsResponseBodyModels extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpu: 'cpu',
            cpuArch: 'cpu_arch',
            created: 'created',
            description: 'description',
            manageRuntime: 'manage_runtime',
            memory: 'memory',
            model: 'model',
            modelId: 'model_id',
        };
    }
    static types() {
        return {
            cpu: 'number',
            cpuArch: 'string',
            created: 'string',
            description: 'string',
            manageRuntime: 'number',
            memory: 'number',
            model: 'string',
            modelId: 'string',
        };
    }
}
exports.DescribeEdgeMachineModelsResponseBodyModels = DescribeEdgeMachineModelsResponseBodyModels;
class DescribeEdgeMachinesResponseBodyEdgeMachines extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activeTime: 'active_time',
            created: 'created',
            edgeMachineId: 'edge_machine_id',
            hostname: 'hostname',
            lifeState: 'life_state',
            model: 'model',
            name: 'name',
            onlineState: 'online_state',
            sn: 'sn',
            updated: 'updated',
        };
    }
    static types() {
        return {
            activeTime: 'string',
            created: 'string',
            edgeMachineId: 'string',
            hostname: 'string',
            lifeState: 'string',
            model: 'string',
            name: 'string',
            onlineState: 'string',
            sn: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeEdgeMachinesResponseBodyEdgeMachines = DescribeEdgeMachinesResponseBodyEdgeMachines;
class DescribeEdgeMachinesResponseBodyPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeEdgeMachinesResponseBodyPageInfo = DescribeEdgeMachinesResponseBodyPageInfo;
class DescribeEventsResponseBodyEventsData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            level: 'level',
            message: 'message',
            reason: 'reason',
        };
    }
    static types() {
        return {
            level: 'string',
            message: 'string',
            reason: 'string',
        };
    }
}
exports.DescribeEventsResponseBodyEventsData = DescribeEventsResponseBodyEventsData;
class DescribeEventsResponseBodyEvents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            data: 'data',
            eventId: 'event_id',
            source: 'source',
            subject: 'subject',
            time: 'time',
            type: 'type',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            data: DescribeEventsResponseBodyEventsData,
            eventId: 'string',
            source: 'string',
            subject: 'string',
            time: 'string',
            type: 'string',
        };
    }
}
exports.DescribeEventsResponseBodyEvents = DescribeEventsResponseBodyEvents;
class DescribeEventsResponseBodyPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeEventsResponseBodyPageInfo = DescribeEventsResponseBodyPageInfo;
class DescribeKubernetesVersionMetadataResponseBodyImages extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            imageId: 'image_id',
            imageName: 'image_name',
            platform: 'platform',
            osVersion: 'os_version',
            imageType: 'image_type',
            osType: 'os_type',
            imageCategory: 'image_category',
            architecture: 'architecture',
        };
    }
    static types() {
        return {
            imageId: 'string',
            imageName: 'string',
            platform: 'string',
            osVersion: 'string',
            imageType: 'string',
            osType: 'string',
            imageCategory: 'string',
            architecture: 'string',
        };
    }
}
exports.DescribeKubernetesVersionMetadataResponseBodyImages = DescribeKubernetesVersionMetadataResponseBodyImages;
class DescribeKubernetesVersionMetadataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            capabilities: 'capabilities',
            images: 'images',
            metaData: 'meta_data',
            runtimes: 'runtimes',
            version: 'version',
            multiAz: 'multi_az',
        };
    }
    static types() {
        return {
            capabilities: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            images: { 'type': 'array', 'itemType': DescribeKubernetesVersionMetadataResponseBodyImages },
            metaData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            runtimes: { 'type': 'array', 'itemType': Runtime },
            version: 'string',
            multiAz: 'string',
        };
    }
}
exports.DescribeKubernetesVersionMetadataResponseBody = DescribeKubernetesVersionMetadataResponseBody;
class DescribeNodePoolVulsResponseBodyVulRecordsVulList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliasName: 'alias_name',
            cveList: 'cve_list',
            name: 'name',
            necessity: 'necessity',
        };
    }
    static types() {
        return {
            aliasName: 'string',
            cveList: { 'type': 'array', 'itemType': 'string' },
            name: 'string',
            necessity: 'string',
        };
    }
}
exports.DescribeNodePoolVulsResponseBodyVulRecordsVulList = DescribeNodePoolVulsResponseBodyVulRecordsVulList;
class DescribeNodePoolVulsResponseBodyVulRecords extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instance_id',
            vulList: 'vul_list',
        };
    }
    static types() {
        return {
            instanceId: 'string',
            vulList: { 'type': 'array', 'itemType': DescribeNodePoolVulsResponseBodyVulRecordsVulList },
        };
    }
}
exports.DescribeNodePoolVulsResponseBodyVulRecords = DescribeNodePoolVulsResponseBodyVulRecords;
class DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            constraintKind: 'constraint_kind',
            msg: 'msg',
            resourceKind: 'resource_kind',
            resourceName: 'resource_name',
            resourceNamespace: 'resource_namespace',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            constraintKind: 'string',
            msg: 'string',
            resourceKind: 'string',
            resourceName: 'string',
            resourceNamespace: 'string',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog = DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog;
class DescribePolicyGovernanceInClusterResponseBodyAdmitLog extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            count: 'count',
            log: 'log',
            progress: 'progress',
        };
    }
    static types() {
        return {
            count: 'number',
            log: DescribePolicyGovernanceInClusterResponseBodyAdmitLogLog,
            progress: 'string',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyAdmitLog = DescribePolicyGovernanceInClusterResponseBodyAdmitLog;
class DescribePolicyGovernanceInClusterResponseBodyOnState extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enabledCount: 'enabled_count',
            severity: 'severity',
            total: 'total',
        };
    }
    static types() {
        return {
            enabledCount: 'number',
            severity: 'string',
            total: 'number',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyOnState = DescribePolicyGovernanceInClusterResponseBodyOnState;
class DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            severity: 'severity',
            violations: 'violations',
        };
    }
    static types() {
        return {
            severity: 'string',
            violations: 'number',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny = DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny;
class DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            severity: 'severity',
            violations: 'violations',
        };
    }
    static types() {
        return {
            severity: 'string',
            violations: 'number',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn = DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn;
class DescribePolicyGovernanceInClusterResponseBodyTotalViolations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deny: 'deny',
            warn: 'warn',
        };
    }
    static types() {
        return {
            deny: DescribePolicyGovernanceInClusterResponseBodyTotalViolationsDeny,
            warn: DescribePolicyGovernanceInClusterResponseBodyTotalViolationsWarn,
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyTotalViolations = DescribePolicyGovernanceInClusterResponseBodyTotalViolations;
class DescribePolicyGovernanceInClusterResponseBodyViolationsDeny extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            policyDescription: 'policyDescription',
            policyName: 'policyName',
            severity: 'severity',
            violations: 'violations',
        };
    }
    static types() {
        return {
            policyDescription: 'string',
            policyName: 'string',
            severity: 'string',
            violations: 'number',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyViolationsDeny = DescribePolicyGovernanceInClusterResponseBodyViolationsDeny;
class DescribePolicyGovernanceInClusterResponseBodyViolationsWarn extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            policyDescription: 'policyDescription',
            policyName: 'policyName',
            severity: 'severity',
            violations: 'violations',
        };
    }
    static types() {
        return {
            policyDescription: 'string',
            policyName: 'string',
            severity: 'string',
            violations: 'number',
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyViolationsWarn = DescribePolicyGovernanceInClusterResponseBodyViolationsWarn;
class DescribePolicyGovernanceInClusterResponseBodyViolations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deny: 'deny',
            warn: 'warn',
        };
    }
    static types() {
        return {
            deny: DescribePolicyGovernanceInClusterResponseBodyViolationsDeny,
            warn: DescribePolicyGovernanceInClusterResponseBodyViolationsWarn,
        };
    }
}
exports.DescribePolicyGovernanceInClusterResponseBodyViolations = DescribePolicyGovernanceInClusterResponseBodyViolations;
class DescribePolicyInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aliUid: 'ali_uid',
            clusterId: 'cluster_id',
            instanceName: 'instance_name',
            policyName: 'policy_name',
            policyCategory: 'policy_category',
            policyDescription: 'policy_description',
            policyParameters: 'policy_parameters',
            policySeverity: 'policy_severity',
            policyScope: 'policy_scope',
            policyAction: 'policy_action',
        };
    }
    static types() {
        return {
            aliUid: 'string',
            clusterId: 'string',
            instanceName: 'string',
            policyName: 'string',
            policyCategory: 'string',
            policyDescription: 'string',
            policyParameters: 'string',
            policySeverity: 'string',
            policyScope: 'string',
            policyAction: 'string',
        };
    }
}
exports.DescribePolicyInstancesResponseBody = DescribePolicyInstancesResponseBody;
class DescribePolicyInstancesStatusResponseBodyPolicyInstances extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            policyCategory: 'policy_category',
            policyDescription: 'policy_description',
            policyInstancesCount: 'policy_instances_count',
            policyName: 'policy_name',
            policySeverity: 'policy_severity',
        };
    }
    static types() {
        return {
            policyCategory: 'string',
            policyDescription: 'string',
            policyInstancesCount: 'number',
            policyName: 'string',
            policySeverity: 'string',
        };
    }
}
exports.DescribePolicyInstancesStatusResponseBodyPolicyInstances = DescribePolicyInstancesStatusResponseBodyPolicyInstances;
class DescribeTaskInfoResponseBodyError extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            message: 'message',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
        };
    }
}
exports.DescribeTaskInfoResponseBodyError = DescribeTaskInfoResponseBodyError;
class DescribeTaskInfoResponseBodyEvents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            level: 'level',
            message: 'message',
            reason: 'reason',
            source: 'source',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            action: 'string',
            level: 'string',
            message: 'string',
            reason: 'string',
            source: 'string',
            timestamp: 'string',
        };
    }
}
exports.DescribeTaskInfoResponseBodyEvents = DescribeTaskInfoResponseBodyEvents;
class DescribeTaskInfoResponseBodyStages extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'end_time',
            message: 'message',
            outputs: 'outputs',
            startTime: 'start_time',
            state: 'state',
        };
    }
    static types() {
        return {
            endTime: 'string',
            message: 'string',
            outputs: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            startTime: 'string',
            state: 'string',
        };
    }
}
exports.DescribeTaskInfoResponseBodyStages = DescribeTaskInfoResponseBodyStages;
class DescribeTaskInfoResponseBodyTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            type: 'type',
        };
    }
    static types() {
        return {
            id: 'string',
            type: 'string',
        };
    }
}
exports.DescribeTaskInfoResponseBodyTarget = DescribeTaskInfoResponseBodyTarget;
class DescribeTaskInfoResponseBodyTaskResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
            status: 'status',
        };
    }
    static types() {
        return {
            data: 'string',
            status: 'string',
        };
    }
}
exports.DescribeTaskInfoResponseBodyTaskResult = DescribeTaskInfoResponseBodyTaskResult;
class DescribeTemplateAttributeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            acl: 'acl',
            name: 'name',
            template: 'template',
            templateType: 'template_type',
            description: 'description',
            tags: 'tags',
            templateWithHistId: 'template_with_hist_id',
            created: 'created',
            updated: 'updated',
        };
    }
    static types() {
        return {
            id: 'string',
            acl: 'string',
            name: 'string',
            template: 'string',
            templateType: 'string',
            description: 'string',
            tags: 'string',
            templateWithHistId: 'string',
            created: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeTemplateAttributeResponseBody = DescribeTemplateAttributeResponseBody;
class DescribeTemplatesResponseBodyPageInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'page_number',
            pageSize: 'page_size',
            totalCount: 'total_count',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
}
exports.DescribeTemplatesResponseBodyPageInfo = DescribeTemplatesResponseBodyPageInfo;
class DescribeTemplatesResponseBodyTemplates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acl: 'acl',
            created: 'created',
            description: 'description',
            id: 'id',
            name: 'name',
            tags: 'tags',
            template: 'template',
            templateType: 'template_type',
            templateWithHistId: 'template_with_hist_id',
            updated: 'updated',
        };
    }
    static types() {
        return {
            acl: 'string',
            created: 'string',
            description: 'string',
            id: 'string',
            name: 'string',
            tags: 'string',
            template: 'string',
            templateType: 'string',
            templateWithHistId: 'string',
            updated: 'string',
        };
    }
}
exports.DescribeTemplatesResponseBodyTemplates = DescribeTemplatesResponseBodyTemplates;
class DescribeTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
            clusterId: 'cluster_id',
            projectId: 'project_id',
            type: 'type',
            action: 'action',
            token: 'token',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
            clusterId: 'string',
            projectId: 'string',
            type: 'string',
            action: 'string',
            token: 'string',
        };
    }
}
exports.DescribeTriggerResponseBody = DescribeTriggerResponseBody;
class DescribeUserPermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceId: 'resource_id',
            resourceType: 'resource_type',
            roleName: 'role_name',
            roleType: 'role_type',
            isOwner: 'is_owner',
            isRamRole: 'is_ram_role',
        };
    }
    static types() {
        return {
            resourceId: 'string',
            resourceType: 'string',
            roleName: 'string',
            roleType: 'string',
            isOwner: 'number',
            isRamRole: 'number',
        };
    }
}
exports.DescribeUserPermissionResponseBody = DescribeUserPermissionResponseBody;
class DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bandwidth: 'bandwidth',
            count: 'count',
            period: 'period',
        };
    }
    static types() {
        return {
            bandwidth: 'number',
            count: 'number',
            period: 'number',
        };
    }
}
exports.DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota = DescribeUserQuotaResponseBodyEdgeImprovedNodepoolQuota;
class DescribeWorkflowsResponseBodyJobs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clusterId: 'cluster_id',
            createTime: 'create_time',
            jobName: 'job_name',
        };
    }
    static types() {
        return {
            clusterId: 'string',
            createTime: 'string',
            jobName: 'string',
        };
    }
}
exports.DescribeWorkflowsResponseBodyJobs = DescribeWorkflowsResponseBodyJobs;
class FixNodePoolVulsRequestRolloutPolicy extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxParallelism: 'max_parallelism',
        };
    }
    static types() {
        return {
            maxParallelism: 'number',
        };
    }
}
exports.FixNodePoolVulsRequestRolloutPolicy = FixNodePoolVulsRequestRolloutPolicy;
class GetKubernetesTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
            clusterId: 'cluster_id',
            projectId: 'project_id',
            type: 'type',
            action: 'action',
            token: 'token',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
            clusterId: 'string',
            projectId: 'string',
            type: 'string',
            action: 'string',
            token: 'string',
        };
    }
}
exports.GetKubernetesTriggerResponseBody = GetKubernetesTriggerResponseBody;
class GetUpgradeStatusResponseBodyUpgradeTask extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            message: 'message',
            status: 'status',
        };
    }
    static types() {
        return {
            message: 'string',
            status: 'string',
        };
    }
}
exports.GetUpgradeStatusResponseBodyUpgradeTask = GetUpgradeStatusResponseBodyUpgradeTask;
class GrantPermissionsRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cluster: 'cluster',
            isCustom: 'is_custom',
            isRamRole: 'is_ram_role',
            namespace: 'namespace',
            roleName: 'role_name',
            roleType: 'role_type',
        };
    }
    static types() {
        return {
            cluster: 'string',
            isCustom: 'boolean',
            isRamRole: 'boolean',
            namespace: 'string',
            roleName: 'string',
            roleType: 'string',
        };
    }
}
exports.GrantPermissionsRequestBody = GrantPermissionsRequestBody;
class InstallClusterAddonsRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            config: 'config',
            name: 'name',
            version: 'version',
        };
    }
    static types() {
        return {
            config: 'string',
            name: 'string',
            version: 'string',
        };
    }
}
exports.InstallClusterAddonsRequestBody = InstallClusterAddonsRequestBody;
class ListTagResourcesResponseBodyTagResourcesTagResource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resourceId: 'resource_id',
            resourceType: 'resource_type',
            tagKey: 'tag_key',
            tagValue: 'tag_value',
        };
    }
    static types() {
        return {
            resourceId: 'string',
            resourceType: 'string',
            tagKey: 'string',
            tagValue: 'string',
        };
    }
}
exports.ListTagResourcesResponseBodyTagResourcesTagResource = ListTagResourcesResponseBodyTagResourcesTagResource;
class ListTagResourcesResponseBodyTagResources extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagResource: 'tag_resource',
        };
    }
    static types() {
        return {
            tagResource: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResourcesTagResource },
        };
    }
}
exports.ListTagResourcesResponseBodyTagResources = ListTagResourcesResponseBodyTagResources;
class ModifyClusterConfigurationRequestCustomizeConfigConfigs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.ModifyClusterConfigurationRequestCustomizeConfigConfigs = ModifyClusterConfigurationRequestCustomizeConfigConfigs;
class ModifyClusterConfigurationRequestCustomizeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            configs: 'configs',
            name: 'name',
        };
    }
    static types() {
        return {
            configs: { 'type': 'array', 'itemType': ModifyClusterConfigurationRequestCustomizeConfigConfigs },
            name: 'string',
        };
    }
}
exports.ModifyClusterConfigurationRequestCustomizeConfig = ModifyClusterConfigurationRequestCustomizeConfig;
class ModifyClusterNodePoolRequestAutoScaling extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            eipBandwidth: 'eip_bandwidth',
            eipInternetChargeType: 'eip_internet_charge_type',
            enable: 'enable',
            isBondEip: 'is_bond_eip',
            maxInstances: 'max_instances',
            minInstances: 'min_instances',
            type: 'type',
        };
    }
    static types() {
        return {
            eipBandwidth: 'number',
            eipInternetChargeType: 'string',
            enable: 'boolean',
            isBondEip: 'boolean',
            maxInstances: 'number',
            minInstances: 'number',
            type: 'string',
        };
    }
}
exports.ModifyClusterNodePoolRequestAutoScaling = ModifyClusterNodePoolRequestAutoScaling;
class ModifyClusterNodePoolRequestKubernetesConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cmsEnabled: 'cms_enabled',
            cpuPolicy: 'cpu_policy',
            labels: 'labels',
            runtime: 'runtime',
            runtimeVersion: 'runtime_version',
            taints: 'taints',
            userData: 'user_data',
        };
    }
    static types() {
        return {
            cmsEnabled: 'boolean',
            cpuPolicy: 'string',
            labels: { 'type': 'array', 'itemType': Tag },
            runtime: 'string',
            runtimeVersion: 'string',
            taints: { 'type': 'array', 'itemType': Taint },
            userData: 'string',
        };
    }
}
exports.ModifyClusterNodePoolRequestKubernetesConfig = ModifyClusterNodePoolRequestKubernetesConfig;
class ModifyClusterNodePoolRequestManagementUpgradeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoUpgrade: 'auto_upgrade',
            maxUnavailable: 'max_unavailable',
            surge: 'surge',
            surgePercentage: 'surge_percentage',
        };
    }
    static types() {
        return {
            autoUpgrade: 'boolean',
            maxUnavailable: 'number',
            surge: 'number',
            surgePercentage: 'number',
        };
    }
}
exports.ModifyClusterNodePoolRequestManagementUpgradeConfig = ModifyClusterNodePoolRequestManagementUpgradeConfig;
class ModifyClusterNodePoolRequestManagement extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRepair: 'auto_repair',
            enable: 'enable',
            upgradeConfig: 'upgrade_config',
        };
    }
    static types() {
        return {
            autoRepair: 'boolean',
            enable: 'boolean',
            upgradeConfig: ModifyClusterNodePoolRequestManagementUpgradeConfig,
        };
    }
}
exports.ModifyClusterNodePoolRequestManagement = ModifyClusterNodePoolRequestManagement;
class ModifyClusterNodePoolRequestNodepoolInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            resourceGroupId: 'resource_group_id',
        };
    }
    static types() {
        return {
            name: 'string',
            resourceGroupId: 'string',
        };
    }
}
exports.ModifyClusterNodePoolRequestNodepoolInfo = ModifyClusterNodePoolRequestNodepoolInfo;
class ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceType: 'instance_type',
            priceLimit: 'price_limit',
        };
    }
    static types() {
        return {
            instanceType: 'string',
            priceLimit: 'string',
        };
    }
}
exports.ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit = ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit;
class ModifyClusterNodePoolRequestScalingGroup extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoRenew: 'auto_renew',
            autoRenewPeriod: 'auto_renew_period',
            compensateWithOnDemand: 'compensate_with_on_demand',
            dataDisks: 'data_disks',
            desiredSize: 'desired_size',
            imageId: 'image_id',
            instanceChargeType: 'instance_charge_type',
            instanceTypes: 'instance_types',
            internetChargeType: 'internet_charge_type',
            internetMaxBandwidthOut: 'internet_max_bandwidth_out',
            keyPair: 'key_pair',
            loginPassword: 'login_password',
            multiAzPolicy: 'multi_az_policy',
            onDemandBaseCapacity: 'on_demand_base_capacity',
            onDemandPercentageAboveBaseCapacity: 'on_demand_percentage_above_base_capacity',
            period: 'period',
            periodUnit: 'period_unit',
            platform: 'platform',
            rdsInstances: 'rds_instances',
            scalingPolicy: 'scaling_policy',
            spotInstancePools: 'spot_instance_pools',
            spotInstanceRemedy: 'spot_instance_remedy',
            spotPriceLimit: 'spot_price_limit',
            spotStrategy: 'spot_strategy',
            systemDiskCategory: 'system_disk_category',
            systemDiskPerformanceLevel: 'system_disk_performance_level',
            systemDiskSize: 'system_disk_size',
            tags: 'tags',
            vswitchIds: 'vswitch_ids',
        };
    }
    static types() {
        return {
            autoRenew: 'boolean',
            autoRenewPeriod: 'number',
            compensateWithOnDemand: 'boolean',
            dataDisks: { 'type': 'array', 'itemType': DataDisk },
            desiredSize: 'number',
            imageId: 'string',
            instanceChargeType: 'string',
            instanceTypes: { 'type': 'array', 'itemType': 'string' },
            internetChargeType: 'string',
            internetMaxBandwidthOut: 'number',
            keyPair: 'string',
            loginPassword: 'string',
            multiAzPolicy: 'string',
            onDemandBaseCapacity: 'number',
            onDemandPercentageAboveBaseCapacity: 'number',
            period: 'number',
            periodUnit: 'string',
            platform: 'string',
            rdsInstances: { 'type': 'array', 'itemType': 'string' },
            scalingPolicy: 'string',
            spotInstancePools: 'number',
            spotInstanceRemedy: 'boolean',
            spotPriceLimit: { 'type': 'array', 'itemType': ModifyClusterNodePoolRequestScalingGroupSpotPriceLimit },
            spotStrategy: 'string',
            systemDiskCategory: 'string',
            systemDiskPerformanceLevel: 'string',
            systemDiskSize: 'number',
            tags: { 'type': 'array', 'itemType': Tag },
            vswitchIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ModifyClusterNodePoolRequestScalingGroup = ModifyClusterNodePoolRequestScalingGroup;
class ModifyClusterNodePoolRequestTeeConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            teeEnable: 'tee_enable',
        };
    }
    static types() {
        return {
            teeEnable: 'boolean',
        };
    }
}
exports.ModifyClusterNodePoolRequestTeeConfig = ModifyClusterNodePoolRequestTeeConfig;
class ModifyNodePoolNodeConfigRequestKubeletConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cpuManagerPolicy: 'cpuManagerPolicy',
            eventBurst: 'eventBurst',
            eventRecordQPS: 'eventRecordQPS',
            evictionHard: 'evictionHard',
            evictionSoft: 'evictionSoft',
            evictionSoftGracePeriod: 'evictionSoftGracePeriod',
            kubeAPIBurst: 'kubeAPIBurst',
            kubeAPIQPS: 'kubeAPIQPS',
            kubeReserved: 'kubeReserved',
            registryBurst: 'registryBurst',
            registryPullQPS: 'registryPullQPS',
            serializeImagePulls: 'serializeImagePulls',
            systemReserved: 'systemReserved',
        };
    }
    static types() {
        return {
            cpuManagerPolicy: 'string',
            eventBurst: 'number',
            eventRecordQPS: 'number',
            evictionHard: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            evictionSoft: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            evictionSoftGracePeriod: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            kubeAPIBurst: 'number',
            kubeAPIQPS: 'number',
            kubeReserved: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            registryBurst: 'number',
            registryPullQPS: 'number',
            serializeImagePulls: 'boolean',
            systemReserved: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.ModifyNodePoolNodeConfigRequestKubeletConfig = ModifyNodePoolNodeConfigRequestKubeletConfig;
class ModifyNodePoolNodeConfigRequestRollingPolicy extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxParallelism: 'max_parallelism',
        };
    }
    static types() {
        return {
            maxParallelism: 'number',
        };
    }
}
exports.ModifyNodePoolNodeConfigRequestRollingPolicy = ModifyNodePoolNodeConfigRequestRollingPolicy;
class ScaleClusterRequestTags extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
        };
    }
    static types() {
        return {
            key: 'string',
        };
    }
}
exports.ScaleClusterRequestTags = ScaleClusterRequestTags;
class ScaleClusterRequestTaints extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            effect: 'effect',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            effect: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.ScaleClusterRequestTaints = ScaleClusterRequestTaints;
class ScaleClusterRequestWorkerDataDisks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'category',
            encrypted: 'encrypted',
            size: 'size',
        };
    }
    static types() {
        return {
            category: 'string',
            encrypted: 'string',
            size: 'string',
        };
    }
}
exports.ScaleClusterRequestWorkerDataDisks = ScaleClusterRequestWorkerDataDisks;
class ScaleOutClusterRequestWorkerDataDisks extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoSnapshotPolicyId: 'auto_snapshot_policy_id',
            category: 'category',
            encrypted: 'encrypted',
            size: 'size',
        };
    }
    static types() {
        return {
            autoSnapshotPolicyId: 'string',
            category: 'string',
            encrypted: 'string',
            size: 'string',
        };
    }
}
exports.ScaleOutClusterRequestWorkerDataDisks = ScaleOutClusterRequestWorkerDataDisks;
class UnInstallClusterAddonsRequestAddons extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
        };
    }
    static types() {
        return {
            name: 'string',
        };
    }
}
exports.UnInstallClusterAddonsRequestAddons = UnInstallClusterAddonsRequestAddons;
class UpgradeClusterAddonsRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'component_name',
            config: 'config',
            nextVersion: 'next_version',
            version: 'version',
        };
    }
    static types() {
        return {
            componentName: 'string',
            config: 'string',
            nextVersion: 'string',
            version: 'string',
        };
    }
}
exports.UpgradeClusterAddonsRequestBody = UpgradeClusterAddonsRequestBody;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._signatureAlgorithm = "v2";
        this._endpointRule = "regional";
        this._endpointMap = {
            'ap-northeast-2-pop': "cs.aliyuncs.com",
            'cn-beijing-finance-pop': "cs.aliyuncs.com",
            'cn-beijing-gov-1': "cs.aliyuncs.com",
            'cn-beijing-nu16-b01': "cs.aliyuncs.com",
            'cn-edge-1': "cs.aliyuncs.com",
            'cn-fujian': "cs.aliyuncs.com",
            'cn-haidian-cm12-c01': "cs.aliyuncs.com",
            'cn-hangzhou-bj-b01': "cs.aliyuncs.com",
            'cn-hangzhou-internal-prod-1': "cs.aliyuncs.com",
            'cn-hangzhou-internal-test-1': "cs.aliyuncs.com",
            'cn-hangzhou-internal-test-2': "cs.aliyuncs.com",
            'cn-hangzhou-internal-test-3': "cs.aliyuncs.com",
            'cn-hangzhou-test-306': "cs.aliyuncs.com",
            'cn-hongkong-finance-pop': "cs.aliyuncs.com",
            'cn-qingdao-nebula': "cs.aliyuncs.com",
            'cn-shanghai-et15-b01': "cs.aliyuncs.com",
            'cn-shanghai-et2-b01': "cs.aliyuncs.com",
            'cn-shanghai-inner': "cs.aliyuncs.com",
            'cn-shanghai-internal-test-1': "cs.aliyuncs.com",
            'cn-shenzhen-inner': "cs.aliyuncs.com",
            'cn-shenzhen-st4-d01': "cs.aliyuncs.com",
            'cn-shenzhen-su18-b01': "cs.aliyuncs.com",
            'cn-wuhan': "cs.aliyuncs.com",
            'cn-yushanfang': "cs.aliyuncs.com",
            'cn-zhangbei': "cs.aliyuncs.com",
            'cn-zhangbei-na61-b01': "cs.aliyuncs.com",
            'cn-zhangjiakou-na62-a01': "cs.aliyuncs.com",
            'cn-zhengzhou-nebula-1': "cs.aliyuncs.com",
            'eu-west-1-oxs': "cs.aliyuncs.com",
            'rus-west-1-pop': "cs.aliyuncs.com",
        };
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("cs", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    async attachInstances(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.attachInstancesWithOptions(ClusterId, request, headers, runtime);
    }
    async attachInstancesWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cpuPolicy)) {
            body["cpu_policy"] = request.cpuPolicy;
        }
        if (!tea_util_1.default.isUnset(request.formatDisk)) {
            body["format_disk"] = request.formatDisk;
        }
        if (!tea_util_1.default.isUnset(request.imageId)) {
            body["image_id"] = request.imageId;
        }
        if (!tea_util_1.default.isUnset(request.instances)) {
            body["instances"] = request.instances;
        }
        if (!tea_util_1.default.isUnset(request.isEdgeWorker)) {
            body["is_edge_worker"] = request.isEdgeWorker;
        }
        if (!tea_util_1.default.isUnset(request.keepInstanceName)) {
            body["keep_instance_name"] = request.keepInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.keyPair)) {
            body["key_pair"] = request.keyPair;
        }
        if (!tea_util_1.default.isUnset(request.nodepoolId)) {
            body["nodepool_id"] = request.nodepoolId;
        }
        if (!tea_util_1.default.isUnset(request.password)) {
            body["password"] = request.password;
        }
        if (!tea_util_1.default.isUnset(request.rdsInstances)) {
            body["rds_instances"] = request.rdsInstances;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.runtime))) {
            body["runtime"] = request.runtime;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.userData)) {
            body["user_data"] = request.userData;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AttachInstances",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/attach`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AttachInstancesResponse({}));
    }
    async cancelClusterUpgrade(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.cancelClusterUpgradeWithOptions(ClusterId, headers, runtime);
    }
    async cancelClusterUpgradeWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "CancelClusterUpgrade",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/upgrade/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelClusterUpgradeResponse({}));
    }
    async cancelComponentUpgrade(clusterId, componentId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.cancelComponentUpgradeWithOptions(clusterId, componentId, headers, runtime);
    }
    async cancelComponentUpgradeWithOptions(clusterId, componentId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "CancelComponentUpgrade",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/components/${openapi_util_1.default.getEncodeParam(componentId)}/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelComponentUpgradeResponse({}));
    }
    async cancelTask(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.cancelTaskWithOptions(taskId, headers, runtime);
    }
    async cancelTaskWithOptions(taskId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "CancelTask",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tasks/${openapi_util_1.default.getEncodeParam(taskId)}/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelTaskResponse({}));
    }
    async cancelWorkflow(workflowName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.cancelWorkflowWithOptions(workflowName, request, headers, runtime);
    }
    async cancelWorkflowWithOptions(workflowName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CancelWorkflow",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/gs/workflow/${openapi_util_1.default.getEncodeParam(workflowName)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CancelWorkflowResponse({}));
    }
    async createAutoscalingConfig(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createAutoscalingConfigWithOptions(ClusterId, request, headers, runtime);
    }
    async createAutoscalingConfigWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolDownDuration)) {
            body["cool_down_duration"] = request.coolDownDuration;
        }
        if (!tea_util_1.default.isUnset(request.expander)) {
            body["expander"] = request.expander;
        }
        if (!tea_util_1.default.isUnset(request.gpuUtilizationThreshold)) {
            body["gpu_utilization_threshold"] = request.gpuUtilizationThreshold;
        }
        if (!tea_util_1.default.isUnset(request.scaleDownEnabled)) {
            body["scale_down_enabled"] = request.scaleDownEnabled;
        }
        if (!tea_util_1.default.isUnset(request.scanInterval)) {
            body["scan_interval"] = request.scanInterval;
        }
        if (!tea_util_1.default.isUnset(request.unneededDuration)) {
            body["unneeded_duration"] = request.unneededDuration;
        }
        if (!tea_util_1.default.isUnset(request.utilizationThreshold)) {
            body["utilization_threshold"] = request.utilizationThreshold;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAutoscalingConfig",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/cluster/${openapi_util_1.default.getEncodeParam(ClusterId)}/autoscale/config/`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateAutoscalingConfigResponse({}));
    }
    async createCluster(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createClusterWithOptions(request, headers, runtime);
    }
    async createClusterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.addons)) {
            body["addons"] = request.addons;
        }
        if (!tea_util_1.default.isUnset(request.apiAudiences)) {
            body["api_audiences"] = request.apiAudiences;
        }
        if (!tea_util_1.default.isUnset(request.chargeType)) {
            body["charge_type"] = request.chargeType;
        }
        if (!tea_util_1.default.isUnset(request.cisEnabled)) {
            body["cis_enabled"] = request.cisEnabled;
        }
        if (!tea_util_1.default.isUnset(request.cloudMonitorFlags)) {
            body["cloud_monitor_flags"] = request.cloudMonitorFlags;
        }
        if (!tea_util_1.default.isUnset(request.clusterDomain)) {
            body["cluster_domain"] = request.clusterDomain;
        }
        if (!tea_util_1.default.isUnset(request.clusterSpec)) {
            body["cluster_spec"] = request.clusterSpec;
        }
        if (!tea_util_1.default.isUnset(request.clusterType)) {
            body["cluster_type"] = request.clusterType;
        }
        if (!tea_util_1.default.isUnset(request.containerCidr)) {
            body["container_cidr"] = request.containerCidr;
        }
        if (!tea_util_1.default.isUnset(request.controlplaneLogComponents)) {
            body["controlplane_log_components"] = request.controlplaneLogComponents;
        }
        if (!tea_util_1.default.isUnset(request.controlplaneLogProject)) {
            body["controlplane_log_project"] = request.controlplaneLogProject;
        }
        if (!tea_util_1.default.isUnset(request.controlplaneLogTtl)) {
            body["controlplane_log_ttl"] = request.controlplaneLogTtl;
        }
        if (!tea_util_1.default.isUnset(request.cpuPolicy)) {
            body["cpu_policy"] = request.cpuPolicy;
        }
        if (!tea_util_1.default.isUnset(request.customSan)) {
            body["custom_san"] = request.customSan;
        }
        if (!tea_util_1.default.isUnset(request.deletionProtection)) {
            body["deletion_protection"] = request.deletionProtection;
        }
        if (!tea_util_1.default.isUnset(request.disableRollback)) {
            body["disable_rollback"] = request.disableRollback;
        }
        if (!tea_util_1.default.isUnset(request.enableRrsa)) {
            body["enable_rrsa"] = request.enableRrsa;
        }
        if (!tea_util_1.default.isUnset(request.encryptionProviderKey)) {
            body["encryption_provider_key"] = request.encryptionProviderKey;
        }
        if (!tea_util_1.default.isUnset(request.endpointPublicAccess)) {
            body["endpoint_public_access"] = request.endpointPublicAccess;
        }
        if (!tea_util_1.default.isUnset(request.formatDisk)) {
            body["format_disk"] = request.formatDisk;
        }
        if (!tea_util_1.default.isUnset(request.imageId)) {
            body["image_id"] = request.imageId;
        }
        if (!tea_util_1.default.isUnset(request.imageType)) {
            body["image_type"] = request.imageType;
        }
        if (!tea_util_1.default.isUnset(request.instances)) {
            body["instances"] = request.instances;
        }
        if (!tea_util_1.default.isUnset(request.ipStack)) {
            body["ip_stack"] = request.ipStack;
        }
        if (!tea_util_1.default.isUnset(request.isEnterpriseSecurityGroup)) {
            body["is_enterprise_security_group"] = request.isEnterpriseSecurityGroup;
        }
        if (!tea_util_1.default.isUnset(request.keepInstanceName)) {
            body["keep_instance_name"] = request.keepInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.keyPair)) {
            body["key_pair"] = request.keyPair;
        }
        if (!tea_util_1.default.isUnset(request.kubernetesVersion)) {
            body["kubernetes_version"] = request.kubernetesVersion;
        }
        if (!tea_util_1.default.isUnset(request.loadBalancerSpec)) {
            body["load_balancer_spec"] = request.loadBalancerSpec;
        }
        if (!tea_util_1.default.isUnset(request.loggingType)) {
            body["logging_type"] = request.loggingType;
        }
        if (!tea_util_1.default.isUnset(request.loginPassword)) {
            body["login_password"] = request.loginPassword;
        }
        if (!tea_util_1.default.isUnset(request.masterAutoRenew)) {
            body["master_auto_renew"] = request.masterAutoRenew;
        }
        if (!tea_util_1.default.isUnset(request.masterAutoRenewPeriod)) {
            body["master_auto_renew_period"] = request.masterAutoRenewPeriod;
        }
        if (!tea_util_1.default.isUnset(request.masterCount)) {
            body["master_count"] = request.masterCount;
        }
        if (!tea_util_1.default.isUnset(request.masterInstanceChargeType)) {
            body["master_instance_charge_type"] = request.masterInstanceChargeType;
        }
        if (!tea_util_1.default.isUnset(request.masterInstanceTypes)) {
            body["master_instance_types"] = request.masterInstanceTypes;
        }
        if (!tea_util_1.default.isUnset(request.masterPeriod)) {
            body["master_period"] = request.masterPeriod;
        }
        if (!tea_util_1.default.isUnset(request.masterPeriodUnit)) {
            body["master_period_unit"] = request.masterPeriodUnit;
        }
        if (!tea_util_1.default.isUnset(request.masterSystemDiskCategory)) {
            body["master_system_disk_category"] = request.masterSystemDiskCategory;
        }
        if (!tea_util_1.default.isUnset(request.masterSystemDiskPerformanceLevel)) {
            body["master_system_disk_performance_level"] = request.masterSystemDiskPerformanceLevel;
        }
        if (!tea_util_1.default.isUnset(request.masterSystemDiskSize)) {
            body["master_system_disk_size"] = request.masterSystemDiskSize;
        }
        if (!tea_util_1.default.isUnset(request.masterSystemDiskSnapshotPolicyId)) {
            body["master_system_disk_snapshot_policy_id"] = request.masterSystemDiskSnapshotPolicyId;
        }
        if (!tea_util_1.default.isUnset(request.masterVswitchIds)) {
            body["master_vswitch_ids"] = request.masterVswitchIds;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.natGateway)) {
            body["nat_gateway"] = request.natGateway;
        }
        if (!tea_util_1.default.isUnset(request.nodeCidrMask)) {
            body["node_cidr_mask"] = request.nodeCidrMask;
        }
        if (!tea_util_1.default.isUnset(request.nodeNameMode)) {
            body["node_name_mode"] = request.nodeNameMode;
        }
        if (!tea_util_1.default.isUnset(request.nodePortRange)) {
            body["node_port_range"] = request.nodePortRange;
        }
        if (!tea_util_1.default.isUnset(request.numOfNodes)) {
            body["num_of_nodes"] = request.numOfNodes;
        }
        if (!tea_util_1.default.isUnset(request.osType)) {
            body["os_type"] = request.osType;
        }
        if (!tea_util_1.default.isUnset(request.period)) {
            body["period"] = request.period;
        }
        if (!tea_util_1.default.isUnset(request.periodUnit)) {
            body["period_unit"] = request.periodUnit;
        }
        if (!tea_util_1.default.isUnset(request.platform)) {
            body["platform"] = request.platform;
        }
        if (!tea_util_1.default.isUnset(request.podVswitchIds)) {
            body["pod_vswitch_ids"] = request.podVswitchIds;
        }
        if (!tea_util_1.default.isUnset(request.profile)) {
            body["profile"] = request.profile;
        }
        if (!tea_util_1.default.isUnset(request.proxyMode)) {
            body["proxy_mode"] = request.proxyMode;
        }
        if (!tea_util_1.default.isUnset(request.rdsInstances)) {
            body["rds_instances"] = request.rdsInstances;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            body["region_id"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            body["resource_group_id"] = request.resourceGroupId;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.runtime))) {
            body["runtime"] = request.runtime;
        }
        if (!tea_util_1.default.isUnset(request.securityGroupId)) {
            body["security_group_id"] = request.securityGroupId;
        }
        if (!tea_util_1.default.isUnset(request.serviceAccountIssuer)) {
            body["service_account_issuer"] = request.serviceAccountIssuer;
        }
        if (!tea_util_1.default.isUnset(request.serviceCidr)) {
            body["service_cidr"] = request.serviceCidr;
        }
        if (!tea_util_1.default.isUnset(request.serviceDiscoveryTypes)) {
            body["service_discovery_types"] = request.serviceDiscoveryTypes;
        }
        if (!tea_util_1.default.isUnset(request.snatEntry)) {
            body["snat_entry"] = request.snatEntry;
        }
        if (!tea_util_1.default.isUnset(request.socEnabled)) {
            body["soc_enabled"] = request.socEnabled;
        }
        if (!tea_util_1.default.isUnset(request.sshFlags)) {
            body["ssh_flags"] = request.sshFlags;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.taints)) {
            body["taints"] = request.taints;
        }
        if (!tea_util_1.default.isUnset(request.timeoutMins)) {
            body["timeout_mins"] = request.timeoutMins;
        }
        if (!tea_util_1.default.isUnset(request.timezone)) {
            body["timezone"] = request.timezone;
        }
        if (!tea_util_1.default.isUnset(request.userCa)) {
            body["user_ca"] = request.userCa;
        }
        if (!tea_util_1.default.isUnset(request.userData)) {
            body["user_data"] = request.userData;
        }
        if (!tea_util_1.default.isUnset(request.vpcid)) {
            body["vpcid"] = request.vpcid;
        }
        if (!tea_util_1.default.isUnset(request.vswitchIds)) {
            body["vswitch_ids"] = request.vswitchIds;
        }
        if (!tea_util_1.default.isUnset(request.workerAutoRenew)) {
            body["worker_auto_renew"] = request.workerAutoRenew;
        }
        if (!tea_util_1.default.isUnset(request.workerAutoRenewPeriod)) {
            body["worker_auto_renew_period"] = request.workerAutoRenewPeriod;
        }
        if (!tea_util_1.default.isUnset(request.workerDataDisks)) {
            body["worker_data_disks"] = request.workerDataDisks;
        }
        if (!tea_util_1.default.isUnset(request.workerInstanceChargeType)) {
            body["worker_instance_charge_type"] = request.workerInstanceChargeType;
        }
        if (!tea_util_1.default.isUnset(request.workerInstanceTypes)) {
            body["worker_instance_types"] = request.workerInstanceTypes;
        }
        if (!tea_util_1.default.isUnset(request.workerPeriod)) {
            body["worker_period"] = request.workerPeriod;
        }
        if (!tea_util_1.default.isUnset(request.workerPeriodUnit)) {
            body["worker_period_unit"] = request.workerPeriodUnit;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskCategory)) {
            body["worker_system_disk_category"] = request.workerSystemDiskCategory;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskPerformanceLevel)) {
            body["worker_system_disk_performance_level"] = request.workerSystemDiskPerformanceLevel;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskSize)) {
            body["worker_system_disk_size"] = request.workerSystemDiskSize;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskSnapshotPolicyId)) {
            body["worker_system_disk_snapshot_policy_id"] = request.workerSystemDiskSnapshotPolicyId;
        }
        if (!tea_util_1.default.isUnset(request.workerVswitchIds)) {
            body["worker_vswitch_ids"] = request.workerVswitchIds;
        }
        if (!tea_util_1.default.isUnset(request.zoneId)) {
            body["zone_id"] = request.zoneId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateClusterResponse({}));
    }
    async createClusterNodePool(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createClusterNodePoolWithOptions(ClusterId, request, headers, runtime);
    }
    async createClusterNodePoolWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.autoScaling))) {
            body["auto_scaling"] = request.autoScaling;
        }
        if (!tea_util_1.default.isUnset(request.count)) {
            body["count"] = request.count;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.interconnectConfig))) {
            body["interconnect_config"] = request.interconnectConfig;
        }
        if (!tea_util_1.default.isUnset(request.interconnectMode)) {
            body["interconnect_mode"] = request.interconnectMode;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.kubernetesConfig))) {
            body["kubernetes_config"] = request.kubernetesConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.management))) {
            body["management"] = request.management;
        }
        if (!tea_util_1.default.isUnset(request.maxNodes)) {
            body["max_nodes"] = request.maxNodes;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.nodepoolInfo))) {
            body["nodepool_info"] = request.nodepoolInfo;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.scalingGroup))) {
            body["scaling_group"] = request.scalingGroup;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.teeConfig))) {
            body["tee_config"] = request.teeConfig;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateClusterNodePool",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateClusterNodePoolResponse({}));
    }
    async createEdgeMachine(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createEdgeMachineWithOptions(request, headers, runtime);
    }
    async createEdgeMachineWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.hostname)) {
            body["hostname"] = request.hostname;
        }
        if (!tea_util_1.default.isUnset(request.model)) {
            body["model"] = request.model;
        }
        if (!tea_util_1.default.isUnset(request.sn)) {
            body["sn"] = request.sn;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateEdgeMachine",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/edge_machines`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateEdgeMachineResponse({}));
    }
    async createKubernetesTrigger(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createKubernetesTriggerWithOptions(request, headers, runtime);
    }
    async createKubernetesTriggerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.clusterId)) {
            body["cluster_id"] = request.clusterId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["project_id"] = request.projectId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateKubernetesTrigger",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/triggers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateKubernetesTriggerResponse({}));
    }
    async createTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createTemplateWithOptions(request, headers, runtime);
    }
    async createTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.template)) {
            body["template"] = request.template;
        }
        if (!tea_util_1.default.isUnset(request.templateType)) {
            body["template_type"] = request.templateType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTemplate",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/templates`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateTemplateResponse({}));
    }
    async createTrigger(clusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createTriggerWithOptions(clusterId, request, headers, runtime);
    }
    async createTriggerWithOptions(clusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.clusterId)) {
            body["cluster_id"] = request.clusterId;
        }
        if (!tea_util_1.default.isUnset(request.projectId)) {
            body["project_id"] = request.projectId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTrigger",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/triggers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateTriggerResponse({}));
    }
    async deleteAlertContact() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteAlertContactWithOptions(headers, runtime);
    }
    async deleteAlertContactWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteAlertContact",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/alert/contacts`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteAlertContactResponse({}));
    }
    async deleteAlertContactGroup() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteAlertContactGroupWithOptions(headers, runtime);
    }
    async deleteAlertContactGroupWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteAlertContactGroup",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/alert/contact_groups`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteAlertContactGroupResponse({}));
    }
    async deleteCluster(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteClusterWithOptions(ClusterId, request, headers, runtime);
    }
    async deleteClusterWithOptions(ClusterId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new DeleteClusterShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.retainResources)) {
            request.retainResourcesShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.retainResources, "retain_resources", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.keepSlb)) {
            query["keep_slb"] = request.keepSlb;
        }
        if (!tea_util_1.default.isUnset(request.retainAllResources)) {
            query["retain_all_resources"] = request.retainAllResources;
        }
        if (!tea_util_1.default.isUnset(request.retainResourcesShrink)) {
            query["retain_resources"] = request.retainResourcesShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteClusterResponse({}));
    }
    async deleteClusterNodepool(ClusterId, NodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteClusterNodepoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
    }
    async deleteClusterNodepoolWithOptions(ClusterId, NodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.force)) {
            query["force"] = request.force;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteClusterNodepool",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteClusterNodepoolResponse({}));
    }
    async deleteClusterNodes(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteClusterNodesWithOptions(ClusterId, request, headers, runtime);
    }
    async deleteClusterNodesWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.drainNode)) {
            body["drain_node"] = request.drainNode;
        }
        if (!tea_util_1.default.isUnset(request.nodes)) {
            body["nodes"] = request.nodes;
        }
        if (!tea_util_1.default.isUnset(request.releaseNode)) {
            body["release_node"] = request.releaseNode;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteClusterNodes",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodes`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteClusterNodesResponse({}));
    }
    async deleteEdgeMachine(edgeMachineid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteEdgeMachineWithOptions(edgeMachineid, request, headers, runtime);
    }
    async deleteEdgeMachineWithOptions(edgeMachineid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.force)) {
            query["force"] = request.force;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteEdgeMachine",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/edge_machines/%5Bedge_machineid%5D`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteEdgeMachineResponse({}));
    }
    async deleteKubernetesTrigger(Id) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteKubernetesTriggerWithOptions(Id, headers, runtime);
    }
    async deleteKubernetesTriggerWithOptions(Id, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteKubernetesTrigger",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/triggers/revoke/${openapi_util_1.default.getEncodeParam(Id)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteKubernetesTriggerResponse({}));
    }
    async deletePolicyInstance(clusterId, policyName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deletePolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
    }
    async deletePolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceName)) {
            query["instance_name"] = request.instanceName;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeletePolicyInstance",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/policies/${openapi_util_1.default.getEncodeParam(policyName)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeletePolicyInstanceResponse({}));
    }
    async deleteTemplate(TemplateId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteTemplateWithOptions(TemplateId, headers, runtime);
    }
    async deleteTemplateWithOptions(TemplateId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteTemplate",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/templates/${openapi_util_1.default.getEncodeParam(TemplateId)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteTemplateResponse({}));
    }
    async deleteTrigger(clusterId, Id) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteTriggerWithOptions(clusterId, Id, headers, runtime);
    }
    async deleteTriggerWithOptions(clusterId, Id, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteTrigger",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/%5Bcluster_id%5D/triggers/%5BId%5D`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteTriggerResponse({}));
    }
    async deployPolicyInstance(clusterId, policyName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deployPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
    }
    async deployPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.namespaces)) {
            body["namespaces"] = request.namespaces;
        }
        if (!tea_util_1.default.isUnset(request.parameters)) {
            body["parameters"] = request.parameters;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeployPolicyInstance",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/policies/${openapi_util_1.default.getEncodeParam(policyName)}`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeployPolicyInstanceResponse({}));
    }
    async descirbeWorkflow(workflowName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.descirbeWorkflowWithOptions(workflowName, headers, runtime);
    }
    async descirbeWorkflowWithOptions(workflowName, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescirbeWorkflow",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/gs/workflow/${openapi_util_1.default.getEncodeParam(workflowName)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescirbeWorkflowResponse({}));
    }
    async describeAddons(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeAddonsWithOptions(request, headers, runtime);
    }
    async describeAddonsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clusterType)) {
            query["cluster_type"] = request.clusterType;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["region"] = request.region;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeAddons",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/components/metadata`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeAddonsResponse({}));
    }
    async describeClusterAddonMetadata(clusterId, componentId, version) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterAddonMetadataWithOptions(clusterId, componentId, version, headers, runtime);
    }
    async describeClusterAddonMetadataWithOptions(clusterId, componentId, version, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterAddonMetadata",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/components/${openapi_util_1.default.getEncodeParam(componentId)}/metadata`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterAddonMetadataResponse({}));
    }
    async describeClusterAddonUpgradeStatus(ClusterId, ComponentId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterAddonUpgradeStatusWithOptions(ClusterId, ComponentId, headers, runtime);
    }
    async describeClusterAddonUpgradeStatusWithOptions(ClusterId, ComponentId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterAddonUpgradeStatus",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/components/${openapi_util_1.default.getEncodeParam(ComponentId)}/upgradestatus`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterAddonUpgradeStatusResponse({}));
    }
    async describeClusterAddonsUpgradeStatus(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterAddonsUpgradeStatusWithOptions(ClusterId, request, headers, runtime);
    }
    async describeClusterAddonsUpgradeStatusWithOptions(ClusterId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new DescribeClusterAddonsUpgradeStatusShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.componentIds)) {
            request.componentIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.componentIds, "componentIds", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.componentIdsShrink)) {
            query["componentIds"] = request.componentIdsShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterAddonsUpgradeStatus",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/components/upgradestatus`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterAddonsUpgradeStatusResponse({}));
    }
    async describeClusterAddonsVersion(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterAddonsVersionWithOptions(ClusterId, headers, runtime);
    }
    async describeClusterAddonsVersionWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterAddonsVersion",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/components/version`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterAddonsVersionResponse({}));
    }
    async describeClusterAttachScripts(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterAttachScriptsWithOptions(ClusterId, request, headers, runtime);
    }
    async describeClusterAttachScriptsWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.arch)) {
            body["arch"] = request.arch;
        }
        if (!tea_util_1.default.isUnset(request.formatDisk)) {
            body["format_disk"] = request.formatDisk;
        }
        if (!tea_util_1.default.isUnset(request.keepInstanceName)) {
            body["keep_instance_name"] = request.keepInstanceName;
        }
        if (!tea_util_1.default.isUnset(request.nodepoolId)) {
            body["nodepool_id"] = request.nodepoolId;
        }
        if (!tea_util_1.default.isUnset(request.options)) {
            body["options"] = request.options;
        }
        if (!tea_util_1.default.isUnset(request.rdsInstances)) {
            body["rds_instances"] = request.rdsInstances;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterAttachScripts",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/attachscript`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "string",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterAttachScriptsResponse({}));
    }
    async describeClusterDetail(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterDetailWithOptions(ClusterId, headers, runtime);
    }
    async describeClusterDetailWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterDetail",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterDetailResponse({}));
    }
    async describeClusterEvents(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterEventsWithOptions(ClusterId, request, headers, runtime);
    }
    async describeClusterEventsWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["page_number"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["page_size"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["task_id"] = request.taskId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterEvents",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/events`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterEventsResponse({}));
    }
    async describeClusterLogs(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterLogsWithOptions(ClusterId, headers, runtime);
    }
    async describeClusterLogsWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterLogs",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/logs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterLogsResponse({}));
    }
    async describeClusterNodePoolDetail(ClusterId, NodepoolId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterNodePoolDetailWithOptions(ClusterId, NodepoolId, headers, runtime);
    }
    async describeClusterNodePoolDetailWithOptions(ClusterId, NodepoolId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterNodePoolDetail",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterNodePoolDetailResponse({}));
    }
    async describeClusterNodePools(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterNodePoolsWithOptions(ClusterId, headers, runtime);
    }
    async describeClusterNodePoolsWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterNodePools",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterNodePoolsResponse({}));
    }
    async describeClusterNodes(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterNodesWithOptions(ClusterId, request, headers, runtime);
    }
    async describeClusterNodesWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceIds)) {
            query["instanceIds"] = request.instanceIds;
        }
        if (!tea_util_1.default.isUnset(request.nodepoolId)) {
            query["nodepool_id"] = request.nodepoolId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.state)) {
            query["state"] = request.state;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterNodes",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodes`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterNodesResponse({}));
    }
    async describeClusterResources(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterResourcesWithOptions(ClusterId, headers, runtime);
    }
    async describeClusterResourcesWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterResources",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/resources`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterResourcesResponse({}));
    }
    async describeClusterTasks(clusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterTasksWithOptions(clusterId, headers, runtime);
    }
    async describeClusterTasksWithOptions(clusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterTasks",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/tasks`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterTasksResponse({}));
    }
    async describeClusterUserKubeconfig(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterUserKubeconfigWithOptions(ClusterId, request, headers, runtime);
    }
    async describeClusterUserKubeconfigWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        if (!tea_util_1.default.isUnset(request.temporaryDurationMinutes)) {
            query["TemporaryDurationMinutes"] = request.temporaryDurationMinutes;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterUserKubeconfig",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/k8s/${openapi_util_1.default.getEncodeParam(ClusterId)}/user_config`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterUserKubeconfigResponse({}));
    }
    async describeClusterV2UserKubeconfig(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClusterV2UserKubeconfigWithOptions(ClusterId, request, headers, runtime);
    }
    async describeClusterV2UserKubeconfigWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusterV2UserKubeconfig",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/k8s/${openapi_util_1.default.getEncodeParam(ClusterId)}/user_config`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClusterV2UserKubeconfigResponse({}));
    }
    async describeClusters(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClustersWithOptions(request, headers, runtime);
    }
    async describeClustersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clusterType)) {
            query["clusterType"] = request.clusterType;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClusters",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClustersResponse({}));
    }
    async describeClustersV1(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeClustersV1WithOptions(request, headers, runtime);
    }
    async describeClustersV1WithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clusterSpec)) {
            query["cluster_spec"] = request.clusterSpec;
        }
        if (!tea_util_1.default.isUnset(request.clusterType)) {
            query["cluster_type"] = request.clusterType;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["page_number"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["page_size"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.profile)) {
            query["profile"] = request.profile;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["region_id"] = request.regionId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeClustersV1",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v1/clusters`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeClustersV1Response({}));
    }
    async describeEdgeMachineActiveProcess(edgeMachineid) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeEdgeMachineActiveProcessWithOptions(edgeMachineid, headers, runtime);
    }
    async describeEdgeMachineActiveProcessWithOptions(edgeMachineid, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeEdgeMachineActiveProcess",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/edge_machines/%5Bedge_machineid%5D/activeprocess`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEdgeMachineActiveProcessResponse({}));
    }
    async describeEdgeMachineModels() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeEdgeMachineModelsWithOptions(headers, runtime);
    }
    async describeEdgeMachineModelsWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeEdgeMachineModels",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/edge_machines/models`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEdgeMachineModelsResponse({}));
    }
    async describeEdgeMachineTunnelConfigDetail(edgeMachineid) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeEdgeMachineTunnelConfigDetailWithOptions(edgeMachineid, headers, runtime);
    }
    async describeEdgeMachineTunnelConfigDetailWithOptions(edgeMachineid, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeEdgeMachineTunnelConfigDetail",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/edge_machines/%5Bedge_machineid%5D/tunnelconfig`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEdgeMachineTunnelConfigDetailResponse({}));
    }
    async describeEdgeMachines(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeEdgeMachinesWithOptions(request, headers, runtime);
    }
    async describeEdgeMachinesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.hostname)) {
            query["hostname"] = request.hostname;
        }
        if (!tea_util_1.default.isUnset(request.lifeState)) {
            query["life_state"] = request.lifeState;
        }
        if (!tea_util_1.default.isUnset(request.model)) {
            query["model"] = request.model;
        }
        if (!tea_util_1.default.isUnset(request.onlineState)) {
            query["online_state"] = request.onlineState;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["page_number"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["page_size"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeEdgeMachines",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/edge_machines`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEdgeMachinesResponse({}));
    }
    async describeEvents(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeEventsWithOptions(request, headers, runtime);
    }
    async describeEventsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clusterId)) {
            query["cluster_id"] = request.clusterId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["page_number"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["page_size"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeEvents",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/events`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeEventsResponse({}));
    }
    async describeExternalAgent(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeExternalAgentWithOptions(ClusterId, request, headers, runtime);
    }
    async describeExternalAgentWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.privateIpAddress)) {
            query["PrivateIpAddress"] = request.privateIpAddress;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeExternalAgent",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/k8s/${openapi_util_1.default.getEncodeParam(ClusterId)}/external/agent/deployment`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeExternalAgentResponse({}));
    }
    async describeKubernetesVersionMetadata(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeKubernetesVersionMetadataWithOptions(request, headers, runtime);
    }
    async describeKubernetesVersionMetadataWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.clusterType)) {
            query["ClusterType"] = request.clusterType;
        }
        if (!tea_util_1.default.isUnset(request.kubernetesVersion)) {
            query["KubernetesVersion"] = request.kubernetesVersion;
        }
        if (!tea_util_1.default.isUnset(request.profile)) {
            query["Profile"] = request.profile;
        }
        if (!tea_util_1.default.isUnset(request.region)) {
            query["Region"] = request.region;
        }
        if (!tea_util_1.default.isUnset(request.runtime)) {
            query["runtime"] = request.runtime;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeKubernetesVersionMetadata",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v1/metadata/versions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeKubernetesVersionMetadataResponse({}));
    }
    async describeNodePoolVuls(clusterId, nodepoolId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeNodePoolVulsWithOptions(clusterId, nodepoolId, headers, runtime);
    }
    async describeNodePoolVulsWithOptions(clusterId, nodepoolId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeNodePoolVuls",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(nodepoolId)}/vuls`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeNodePoolVulsResponse({}));
    }
    async describePolicies() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describePoliciesWithOptions(headers, runtime);
    }
    async describePoliciesWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribePolicies",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/policies`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePoliciesResponse({}));
    }
    async describePolicyDetails(policyName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describePolicyDetailsWithOptions(policyName, headers, runtime);
    }
    async describePolicyDetailsWithOptions(policyName, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribePolicyDetails",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/policies/${openapi_util_1.default.getEncodeParam(policyName)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePolicyDetailsResponse({}));
    }
    async describePolicyGovernanceInCluster(clusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describePolicyGovernanceInClusterWithOptions(clusterId, headers, runtime);
    }
    async describePolicyGovernanceInClusterWithOptions(clusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribePolicyGovernanceInCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/policygovernance`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePolicyGovernanceInClusterResponse({}));
    }
    async describePolicyInstances(clusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describePolicyInstancesWithOptions(clusterId, request, headers, runtime);
    }
    async describePolicyInstancesWithOptions(clusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.instanceName)) {
            query["instance_name"] = request.instanceName;
        }
        if (!tea_util_1.default.isUnset(request.policyName)) {
            query["policy_name"] = request.policyName;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribePolicyInstances",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/policies`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePolicyInstancesResponse({}));
    }
    async describePolicyInstancesStatus(clusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describePolicyInstancesStatusWithOptions(clusterId, headers, runtime);
    }
    async describePolicyInstancesStatusWithOptions(clusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribePolicyInstancesStatus",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/policies/status`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribePolicyInstancesStatusResponse({}));
    }
    async describeTaskInfo(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeTaskInfoWithOptions(taskId, headers, runtime);
    }
    async describeTaskInfoWithOptions(taskId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeTaskInfo",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tasks/${openapi_util_1.default.getEncodeParam(taskId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTaskInfoResponse({}));
    }
    async describeTemplateAttribute(TemplateId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeTemplateAttributeWithOptions(TemplateId, request, headers, runtime);
    }
    async describeTemplateAttributeWithOptions(TemplateId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.templateType)) {
            query["template_type"] = request.templateType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeTemplateAttribute",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/templates/${openapi_util_1.default.getEncodeParam(TemplateId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTemplateAttributeResponse({}));
    }
    async describeTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeTemplatesWithOptions(request, headers, runtime);
    }
    async describeTemplatesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            query["page_num"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["page_size"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.templateType)) {
            query["template_type"] = request.templateType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeTemplates",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/templates`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTemplatesResponse({}));
    }
    async describeTrigger(clusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeTriggerWithOptions(clusterId, request, headers, runtime);
    }
    async describeTriggerWithOptions(clusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.namespace)) {
            query["Namespace"] = request.namespace;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.action)) {
            query["action"] = request.action;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeTrigger",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/%5Bcluster_id%5D/triggers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeTriggerResponse({}));
    }
    async describeUserPermission(uid) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeUserPermissionWithOptions(uid, headers, runtime);
    }
    async describeUserPermissionWithOptions(uid, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeUserPermission",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/permissions/users/${openapi_util_1.default.getEncodeParam(uid)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserPermissionResponse({}));
    }
    async describeUserQuota() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeUserQuotaWithOptions(headers, runtime);
    }
    async describeUserQuotaWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeUserQuota",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/quota`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeUserQuotaResponse({}));
    }
    async describeWorkflows() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeWorkflowsWithOptions(headers, runtime);
    }
    async describeWorkflowsWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeWorkflows",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/gs/workflows`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeWorkflowsResponse({}));
    }
    async edgeClusterAddEdgeMachine(clusterid, edgeMachineid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.edgeClusterAddEdgeMachineWithOptions(clusterid, edgeMachineid, request, headers, runtime);
    }
    async edgeClusterAddEdgeMachineWithOptions(clusterid, edgeMachineid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.expired)) {
            body["expired"] = request.expired;
        }
        if (!tea_util_1.default.isUnset(request.nodepoolId)) {
            body["nodepool_id"] = request.nodepoolId;
        }
        if (!tea_util_1.default.isUnset(request.options)) {
            body["options"] = request.options;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "EdgeClusterAddEdgeMachine",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/%5Bclusterid%5D/attachedgemachine/%5Bedge_machineid%5D`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new EdgeClusterAddEdgeMachineResponse({}));
    }
    async fixNodePoolVuls(clusterId, nodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.fixNodePoolVulsWithOptions(clusterId, nodepoolId, request, headers, runtime);
    }
    async fixNodePoolVulsWithOptions(clusterId, nodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.nodes)) {
            body["nodes"] = request.nodes;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.rolloutPolicy))) {
            body["rollout_policy"] = request.rolloutPolicy;
        }
        if (!tea_util_1.default.isUnset(request.vulList)) {
            body["vul_list"] = request.vulList;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "FixNodePoolVuls",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(nodepoolId)}/vuls/fix`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new FixNodePoolVulsResponse({}));
    }
    async getKubernetesTrigger(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getKubernetesTriggerWithOptions(ClusterId, request, headers, runtime);
    }
    async getKubernetesTriggerWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.namespace)) {
            query["Namespace"] = request.namespace;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["Type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.action)) {
            query["action"] = request.action;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetKubernetesTrigger",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/triggers/${openapi_util_1.default.getEncodeParam(ClusterId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "array",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetKubernetesTriggerResponse({}));
    }
    async getUpgradeStatus(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getUpgradeStatusWithOptions(ClusterId, headers, runtime);
    }
    async getUpgradeStatusWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "GetUpgradeStatus",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/upgrade/status`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetUpgradeStatusResponse({}));
    }
    async grantPermissions(uid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.grantPermissionsWithOptions(uid, request, headers, runtime);
    }
    async grantPermissionsWithOptions(uid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "GrantPermissions",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/permissions/users/${openapi_util_1.default.getEncodeParam(uid)}`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GrantPermissionsResponse({}));
    }
    async installClusterAddons(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.installClusterAddonsWithOptions(ClusterId, request, headers, runtime);
    }
    async installClusterAddonsWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "InstallClusterAddons",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/components/install`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new InstallClusterAddonsResponse({}));
    }
    async listTagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listTagResourcesWithOptions(request, headers, runtime);
    }
    async listTagResourcesWithOptions(tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new ListTagResourcesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.resourceIds)) {
            request.resourceIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, "resource_ids", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.tags)) {
            request.tagsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.tags, "tags", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["next_token"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["region_id"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceIdsShrink)) {
            query["resource_ids"] = request.resourceIdsShrink;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["resource_type"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tagsShrink)) {
            query["tags"] = request.tagsShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTagResources",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tags`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
    }
    async migrateCluster(clusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.migrateClusterWithOptions(clusterId, request, headers, runtime);
    }
    async migrateClusterWithOptions(clusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.ossBucketEndpoint)) {
            body["oss_bucket_endpoint"] = request.ossBucketEndpoint;
        }
        if (!tea_util_1.default.isUnset(request.ossBucketName)) {
            body["oss_bucket_name"] = request.ossBucketName;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MigrateCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/migrate`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new MigrateClusterResponse({}));
    }
    async modifyCluster(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyClusterWithOptions(ClusterId, request, headers, runtime);
    }
    async modifyClusterWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiServerEip)) {
            body["api_server_eip"] = request.apiServerEip;
        }
        if (!tea_util_1.default.isUnset(request.apiServerEipId)) {
            body["api_server_eip_id"] = request.apiServerEipId;
        }
        if (!tea_util_1.default.isUnset(request.deletionProtection)) {
            body["deletion_protection"] = request.deletionProtection;
        }
        if (!tea_util_1.default.isUnset(request.enableRrsa)) {
            body["enable_rrsa"] = request.enableRrsa;
        }
        if (!tea_util_1.default.isUnset(request.ingressDomainRebinding)) {
            body["ingress_domain_rebinding"] = request.ingressDomainRebinding;
        }
        if (!tea_util_1.default.isUnset(request.ingressLoadbalancerId)) {
            body["ingress_loadbalancer_id"] = request.ingressLoadbalancerId;
        }
        if (!tea_util_1.default.isUnset(request.instanceDeletionProtection)) {
            body["instance_deletion_protection"] = request.instanceDeletionProtection;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.maintenanceWindow))) {
            body["maintenance_window"] = request.maintenanceWindow;
        }
        if (!tea_util_1.default.isUnset(request.resourceGroupId)) {
            body["resource_group_id"] = request.resourceGroupId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyClusterResponse({}));
    }
    async modifyClusterAddon(clusterId, componentId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyClusterAddonWithOptions(clusterId, componentId, request, headers, runtime);
    }
    async modifyClusterAddonWithOptions(clusterId, componentId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.config)) {
            body["config"] = request.config;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyClusterAddon",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/components/${openapi_util_1.default.getEncodeParam(componentId)}/config`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyClusterAddonResponse({}));
    }
    async modifyClusterConfiguration(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyClusterConfigurationWithOptions(ClusterId, request, headers, runtime);
    }
    async modifyClusterConfigurationWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.customizeConfig)) {
            body["customize_config"] = request.customizeConfig;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyClusterConfiguration",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/configuration`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyClusterConfigurationResponse({}));
    }
    async modifyClusterNodePool(ClusterId, NodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
    }
    async modifyClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.autoScaling))) {
            body["auto_scaling"] = request.autoScaling;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.kubernetesConfig))) {
            body["kubernetes_config"] = request.kubernetesConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.management))) {
            body["management"] = request.management;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.nodepoolInfo))) {
            body["nodepool_info"] = request.nodepoolInfo;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.scalingGroup))) {
            body["scaling_group"] = request.scalingGroup;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.teeConfig))) {
            body["tee_config"] = request.teeConfig;
        }
        if (!tea_util_1.default.isUnset(request.updateNodes)) {
            body["update_nodes"] = request.updateNodes;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyClusterNodePool",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyClusterNodePoolResponse({}));
    }
    async modifyClusterTags(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyClusterTagsWithOptions(ClusterId, request, headers, runtime);
    }
    async modifyClusterTagsWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyClusterTags",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/tags`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyClusterTagsResponse({}));
    }
    async modifyNodePoolNodeConfig(ClusterId, NodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyNodePoolNodeConfigWithOptions(ClusterId, NodepoolId, request, headers, runtime);
    }
    async modifyNodePoolNodeConfigWithOptions(ClusterId, NodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.kubeletConfig))) {
            body["kubelet_config"] = request.kubeletConfig;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.rollingPolicy))) {
            body["rolling_policy"] = request.rollingPolicy;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyNodePoolNodeConfig",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}/node_config`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyNodePoolNodeConfigResponse({}));
    }
    async modifyPolicyInstance(clusterId, policyName, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.modifyPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime);
    }
    async modifyPolicyInstanceWithOptions(clusterId, policyName, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.instanceName)) {
            body["instance_name"] = request.instanceName;
        }
        if (!tea_util_1.default.isUnset(request.namespaces)) {
            body["namespaces"] = request.namespaces;
        }
        if (!tea_util_1.default.isUnset(request.parameters)) {
            body["parameters"] = request.parameters;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyPolicyInstance",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/policies/${openapi_util_1.default.getEncodeParam(policyName)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ModifyPolicyInstanceResponse({}));
    }
    async openAckService(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.openAckServiceWithOptions(request, headers, runtime);
    }
    async openAckServiceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "OpenAckService",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/service/open`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new OpenAckServiceResponse({}));
    }
    async pauseClusterUpgrade(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.pauseClusterUpgradeWithOptions(ClusterId, headers, runtime);
    }
    async pauseClusterUpgradeWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "PauseClusterUpgrade",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/upgrade/pause`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PauseClusterUpgradeResponse({}));
    }
    async pauseComponentUpgrade(clusterid, componentid) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.pauseComponentUpgradeWithOptions(clusterid, componentid, headers, runtime);
    }
    async pauseComponentUpgradeWithOptions(clusterid, componentid, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "PauseComponentUpgrade",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterid)}/components/${openapi_util_1.default.getEncodeParam(componentid)}/pause`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PauseComponentUpgradeResponse({}));
    }
    async pauseTask(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.pauseTaskWithOptions(taskId, headers, runtime);
    }
    async pauseTaskWithOptions(taskId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "PauseTask",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tasks/${openapi_util_1.default.getEncodeParam(taskId)}/pause`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new PauseTaskResponse({}));
    }
    async removeClusterNodes(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.removeClusterNodesWithOptions(ClusterId, request, headers, runtime);
    }
    async removeClusterNodesWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.drainNode)) {
            body["drain_node"] = request.drainNode;
        }
        if (!tea_util_1.default.isUnset(request.nodes)) {
            body["nodes"] = request.nodes;
        }
        if (!tea_util_1.default.isUnset(request.releaseNode)) {
            body["release_node"] = request.releaseNode;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RemoveClusterNodes",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodes/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RemoveClusterNodesResponse({}));
    }
    async removeNodePoolNodes(ClusterId, NodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.removeNodePoolNodesWithOptions(ClusterId, NodepoolId, request, headers, runtime);
    }
    async removeNodePoolNodesWithOptions(ClusterId, NodepoolId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new RemoveNodePoolNodesShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.nodes)) {
            request.nodesShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.nodes, "nodes", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.drainNode)) {
            query["drain_node"] = request.drainNode;
        }
        if (!tea_util_1.default.isUnset(request.nodesShrink)) {
            query["nodes"] = request.nodesShrink;
        }
        if (!tea_util_1.default.isUnset(request.releaseNode)) {
            query["release_node"] = request.releaseNode;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RemoveNodePoolNodes",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}/nodes`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RemoveNodePoolNodesResponse({}));
    }
    async removeWorkflow(workflowName) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.removeWorkflowWithOptions(workflowName, headers, runtime);
    }
    async removeWorkflowWithOptions(workflowName, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "RemoveWorkflow",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/gs/workflow/${openapi_util_1.default.getEncodeParam(workflowName)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RemoveWorkflowResponse({}));
    }
    async repairClusterNodePool(clusterId, nodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.repairClusterNodePoolWithOptions(clusterId, nodepoolId, request, headers, runtime);
    }
    async repairClusterNodePoolWithOptions(clusterId, nodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.nodes)) {
            body["nodes"] = request.nodes;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RepairClusterNodePool",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(nodepoolId)}/repair`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RepairClusterNodePoolResponse({}));
    }
    async resumeComponentUpgrade(clusterid, componentid) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.resumeComponentUpgradeWithOptions(clusterid, componentid, headers, runtime);
    }
    async resumeComponentUpgradeWithOptions(clusterid, componentid, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "ResumeComponentUpgrade",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(clusterid)}/components/${openapi_util_1.default.getEncodeParam(componentid)}/resume`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResumeComponentUpgradeResponse({}));
    }
    async resumeTask(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.resumeTaskWithOptions(taskId, headers, runtime);
    }
    async resumeTaskWithOptions(taskId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "ResumeTask",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tasks/${openapi_util_1.default.getEncodeParam(taskId)}/resume`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResumeTaskResponse({}));
    }
    async resumeUpgradeCluster(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.resumeUpgradeClusterWithOptions(ClusterId, headers, runtime);
    }
    async resumeUpgradeClusterWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "ResumeUpgradeCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/upgrade/resume`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ResumeUpgradeClusterResponse({}));
    }
    async scaleCluster(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.scaleClusterWithOptions(ClusterId, request, headers, runtime);
    }
    async scaleClusterWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cloudMonitorFlags)) {
            body["cloud_monitor_flags"] = request.cloudMonitorFlags;
        }
        if (!tea_util_1.default.isUnset(request.count)) {
            body["count"] = request.count;
        }
        if (!tea_util_1.default.isUnset(request.cpuPolicy)) {
            body["cpu_policy"] = request.cpuPolicy;
        }
        if (!tea_util_1.default.isUnset(request.disableRollback)) {
            body["disable_rollback"] = request.disableRollback;
        }
        if (!tea_util_1.default.isUnset(request.keyPair)) {
            body["key_pair"] = request.keyPair;
        }
        if (!tea_util_1.default.isUnset(request.loginPassword)) {
            body["login_password"] = request.loginPassword;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.taints)) {
            body["taints"] = request.taints;
        }
        if (!tea_util_1.default.isUnset(request.vswitchIds)) {
            body["vswitch_ids"] = request.vswitchIds;
        }
        if (!tea_util_1.default.isUnset(request.workerAutoRenew)) {
            body["worker_auto_renew"] = request.workerAutoRenew;
        }
        if (!tea_util_1.default.isUnset(request.workerAutoRenewPeriod)) {
            body["worker_auto_renew_period"] = request.workerAutoRenewPeriod;
        }
        if (!tea_util_1.default.isUnset(request.workerDataDisk)) {
            body["worker_data_disk"] = request.workerDataDisk;
        }
        if (!tea_util_1.default.isUnset(request.workerDataDisks)) {
            body["worker_data_disks"] = request.workerDataDisks;
        }
        if (!tea_util_1.default.isUnset(request.workerInstanceChargeType)) {
            body["worker_instance_charge_type"] = request.workerInstanceChargeType;
        }
        if (!tea_util_1.default.isUnset(request.workerInstanceTypes)) {
            body["worker_instance_types"] = request.workerInstanceTypes;
        }
        if (!tea_util_1.default.isUnset(request.workerPeriod)) {
            body["worker_period"] = request.workerPeriod;
        }
        if (!tea_util_1.default.isUnset(request.workerPeriodUnit)) {
            body["worker_period_unit"] = request.workerPeriodUnit;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskCategory)) {
            body["worker_system_disk_category"] = request.workerSystemDiskCategory;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskSize)) {
            body["worker_system_disk_size"] = request.workerSystemDiskSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ScaleCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ScaleClusterResponse({}));
    }
    async scaleClusterNodePool(ClusterId, NodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.scaleClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
    }
    async scaleClusterNodePoolWithOptions(ClusterId, NodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.count)) {
            body["count"] = request.count;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ScaleClusterNodePool",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ScaleClusterNodePoolResponse({}));
    }
    async scaleOutCluster(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.scaleOutClusterWithOptions(ClusterId, request, headers, runtime);
    }
    async scaleOutClusterWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cloudMonitorFlags)) {
            body["cloud_monitor_flags"] = request.cloudMonitorFlags;
        }
        if (!tea_util_1.default.isUnset(request.count)) {
            body["count"] = request.count;
        }
        if (!tea_util_1.default.isUnset(request.cpuPolicy)) {
            body["cpu_policy"] = request.cpuPolicy;
        }
        if (!tea_util_1.default.isUnset(request.imageId)) {
            body["image_id"] = request.imageId;
        }
        if (!tea_util_1.default.isUnset(request.keyPair)) {
            body["key_pair"] = request.keyPair;
        }
        if (!tea_util_1.default.isUnset(request.loginPassword)) {
            body["login_password"] = request.loginPassword;
        }
        if (!tea_util_1.default.isUnset(request.rdsInstances)) {
            body["rds_instances"] = request.rdsInstances;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.runtime))) {
            body["runtime"] = request.runtime;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.taints)) {
            body["taints"] = request.taints;
        }
        if (!tea_util_1.default.isUnset(request.userData)) {
            body["user_data"] = request.userData;
        }
        if (!tea_util_1.default.isUnset(request.vswitchIds)) {
            body["vswitch_ids"] = request.vswitchIds;
        }
        if (!tea_util_1.default.isUnset(request.workerAutoRenew)) {
            body["worker_auto_renew"] = request.workerAutoRenew;
        }
        if (!tea_util_1.default.isUnset(request.workerAutoRenewPeriod)) {
            body["worker_auto_renew_period"] = request.workerAutoRenewPeriod;
        }
        if (!tea_util_1.default.isUnset(request.workerDataDisks)) {
            body["worker_data_disks"] = request.workerDataDisks;
        }
        if (!tea_util_1.default.isUnset(request.workerInstanceChargeType)) {
            body["worker_instance_charge_type"] = request.workerInstanceChargeType;
        }
        if (!tea_util_1.default.isUnset(request.workerInstanceTypes)) {
            body["worker_instance_types"] = request.workerInstanceTypes;
        }
        if (!tea_util_1.default.isUnset(request.workerPeriod)) {
            body["worker_period"] = request.workerPeriod;
        }
        if (!tea_util_1.default.isUnset(request.workerPeriodUnit)) {
            body["worker_period_unit"] = request.workerPeriodUnit;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskCategory)) {
            body["worker_system_disk_category"] = request.workerSystemDiskCategory;
        }
        if (!tea_util_1.default.isUnset(request.workerSystemDiskSize)) {
            body["worker_system_disk_size"] = request.workerSystemDiskSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ScaleOutCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ScaleOutClusterResponse({}));
    }
    async startWorkflow(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.startWorkflowWithOptions(request, headers, runtime);
    }
    async startWorkflowWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mappingBamOutFilename)) {
            body["mapping_bam_out_filename"] = request.mappingBamOutFilename;
        }
        if (!tea_util_1.default.isUnset(request.mappingBamOutPath)) {
            body["mapping_bam_out_path"] = request.mappingBamOutPath;
        }
        if (!tea_util_1.default.isUnset(request.mappingBucketName)) {
            body["mapping_bucket_name"] = request.mappingBucketName;
        }
        if (!tea_util_1.default.isUnset(request.mappingFastqFirstFilename)) {
            body["mapping_fastq_first_filename"] = request.mappingFastqFirstFilename;
        }
        if (!tea_util_1.default.isUnset(request.mappingFastqPath)) {
            body["mapping_fastq_path"] = request.mappingFastqPath;
        }
        if (!tea_util_1.default.isUnset(request.mappingFastqSecondFilename)) {
            body["mapping_fastq_second_filename"] = request.mappingFastqSecondFilename;
        }
        if (!tea_util_1.default.isUnset(request.mappingIsMarkDup)) {
            body["mapping_is_mark_dup"] = request.mappingIsMarkDup;
        }
        if (!tea_util_1.default.isUnset(request.mappingOssRegion)) {
            body["mapping_oss_region"] = request.mappingOssRegion;
        }
        if (!tea_util_1.default.isUnset(request.mappingReferencePath)) {
            body["mapping_reference_path"] = request.mappingReferencePath;
        }
        if (!tea_util_1.default.isUnset(request.service)) {
            body["service"] = request.service;
        }
        if (!tea_util_1.default.isUnset(request.wgsBucketName)) {
            body["wgs_bucket_name"] = request.wgsBucketName;
        }
        if (!tea_util_1.default.isUnset(request.wgsFastqFirstFilename)) {
            body["wgs_fastq_first_filename"] = request.wgsFastqFirstFilename;
        }
        if (!tea_util_1.default.isUnset(request.wgsFastqPath)) {
            body["wgs_fastq_path"] = request.wgsFastqPath;
        }
        if (!tea_util_1.default.isUnset(request.wgsFastqSecondFilename)) {
            body["wgs_fastq_second_filename"] = request.wgsFastqSecondFilename;
        }
        if (!tea_util_1.default.isUnset(request.wgsOssRegion)) {
            body["wgs_oss_region"] = request.wgsOssRegion;
        }
        if (!tea_util_1.default.isUnset(request.wgsReferencePath)) {
            body["wgs_reference_path"] = request.wgsReferencePath;
        }
        if (!tea_util_1.default.isUnset(request.wgsVcfOutFilename)) {
            body["wgs_vcf_out_filename"] = request.wgsVcfOutFilename;
        }
        if (!tea_util_1.default.isUnset(request.wgsVcfOutPath)) {
            body["wgs_vcf_out_path"] = request.wgsVcfOutPath;
        }
        if (!tea_util_1.default.isUnset(request.workflowType)) {
            body["workflow_type"] = request.workflowType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartWorkflow",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/gs/workflow`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new StartWorkflowResponse({}));
    }
    async tagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.tagResourcesWithOptions(request, headers, runtime);
    }
    async tagResourcesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.regionId)) {
            body["region_id"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceIds)) {
            body["resource_ids"] = request.resourceIds;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            body["resource_type"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TagResources",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tags`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
    }
    async unInstallClusterAddons(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.unInstallClusterAddonsWithOptions(ClusterId, request, headers, runtime);
    }
    async unInstallClusterAddonsWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: tea_util_1.default.toArray(request.addons),
        });
        let params = new $OpenApi.Params({
            action: "UnInstallClusterAddons",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/components/uninstall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UnInstallClusterAddonsResponse({}));
    }
    async untagResources(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.untagResourcesWithOptions(request, headers, runtime);
    }
    async untagResourcesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.all)) {
            query["all"] = request.all;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["region_id"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.resourceIds)) {
            query["resource_ids"] = request.resourceIds;
        }
        if (!tea_util_1.default.isUnset(request.resourceType)) {
            query["resource_type"] = request.resourceType;
        }
        if (!tea_util_1.default.isUnset(request.tagKeys)) {
            query["tag_keys"] = request.tagKeys;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UntagResources",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/tags`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
    }
    async updateContactGroupForAlert(ClusterId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateContactGroupForAlertWithOptions(ClusterId, headers, runtime);
    }
    async updateContactGroupForAlertWithOptions(ClusterId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "UpdateContactGroupForAlert",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/alert/${openapi_util_1.default.getEncodeParam(ClusterId)}/alert_rule/contact_groups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateContactGroupForAlertResponse({}));
    }
    async updateK8sClusterUserConfigExpire(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateK8sClusterUserConfigExpireWithOptions(ClusterId, request, headers, runtime);
    }
    async updateK8sClusterUserConfigExpireWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.expireHour)) {
            body["expire_hour"] = request.expireHour;
        }
        if (!tea_util_1.default.isUnset(request.user)) {
            body["user"] = request.user;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateK8sClusterUserConfigExpire",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/k8s/${openapi_util_1.default.getEncodeParam(ClusterId)}/user_config/expire`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateK8sClusterUserConfigExpireResponse({}));
    }
    async updateTemplate(TemplateId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateTemplateWithOptions(TemplateId, request, headers, runtime);
    }
    async updateTemplateWithOptions(TemplateId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.tags)) {
            body["tags"] = request.tags;
        }
        if (!tea_util_1.default.isUnset(request.template)) {
            body["template"] = request.template;
        }
        if (!tea_util_1.default.isUnset(request.templateType)) {
            body["template_type"] = request.templateType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTemplate",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/templates/${openapi_util_1.default.getEncodeParam(TemplateId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateTemplateResponse({}));
    }
    async upgradeCluster(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.upgradeClusterWithOptions(ClusterId, request, headers, runtime);
    }
    async upgradeClusterWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.componentName)) {
            body["component_name"] = request.componentName;
        }
        if (!tea_util_1.default.isUnset(request.nextVersion)) {
            body["next_version"] = request.nextVersion;
        }
        if (!tea_util_1.default.isUnset(request.version)) {
            body["version"] = request.version;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeCluster",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/api/v2/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/upgrade`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeClusterResponse({}));
    }
    async upgradeClusterAddons(ClusterId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.upgradeClusterAddonsWithOptions(ClusterId, request, headers, runtime);
    }
    async upgradeClusterAddonsWithOptions(ClusterId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeClusterAddons",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/components/upgrade`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "none",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeClusterAddonsResponse({}));
    }
    async upgradeClusterNodepool(ClusterId, NodepoolId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.upgradeClusterNodepoolWithOptions(ClusterId, NodepoolId, request, headers, runtime);
    }
    async upgradeClusterNodepoolWithOptions(ClusterId, NodepoolId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.imageId)) {
            body["image_id"] = request.imageId;
        }
        if (!tea_util_1.default.isUnset(request.kubernetesVersion)) {
            body["kubernetes_version"] = request.kubernetesVersion;
        }
        if (!tea_util_1.default.isUnset(request.runtimeVersion)) {
            body["runtime_version"] = request.runtimeVersion;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpgradeClusterNodepool",
            version: "2015-12-15",
            protocol: "HTTPS",
            pathname: `/clusters/${openapi_util_1.default.getEncodeParam(ClusterId)}/nodepools/${openapi_util_1.default.getEncodeParam(NodepoolId)}/upgrade`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpgradeClusterNodepoolResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map